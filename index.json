{
  "manual/basics.html": {
    "href": "manual/basics.html",
    "title": "Basics | Engine4 Manual",
    "keywords": "Basics The basic part of the library is how you understand the concept of fourth-dimension, how to implement this library to scene, and manipulate objects in scene. The documentation is expecting you to already know and familiar with how to setup 3D objects in Unity Game Engine. If you haven't see and play our examples scene, we recommend you to do so!"
  },
  "manual/extras.html": {
    "href": "manual/extras.html",
    "title": "Extras | Engine4 Manual",
    "keywords": "Extras This special section contains general info regarding asset development."
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Engine4 Manual | Engine4 Manual",
    "keywords": "Engine4 Manual Engine4 have many features to get you up to create four-dimensional games. Basics Introduction to fourth dimension and the library. Modeling Learn to procedurally create a 4D object. Rendering Costumize how it looks, how it projects. Physics Simulate four dimensional objects like in the real world. Scripting Adapt the scene, add some interactions, create magic everywhere. Extras General Information about the library."
  },
  "manual/modeling.html": {
    "href": "manual/modeling.html",
    "title": "Modeling | Engine4 Manual",
    "keywords": "Modeling Engine4 have a lot modeling tools that provides the ease for creating procedural shapes."
  },
  "manual/physics.html": {
    "href": "manual/physics.html",
    "title": "Physics | Engine4 Manual",
    "keywords": "Physics Engine4 have a dedicated custom four-dimensional physics engine so you can simulate objects like the real world. Features in Glance Where the physics engine supports: Collision shapes: Box , Sphere , Capsule Collision solver: Multicontact , Friction , Bounce Optimization: Dynamic Bounding Tree , Sleep , World Bounding Where the physics engine is in development: Raycast Collision Callback Where the physics engine is currently lack of: Convex and concave shapes Character controller Joints"
  },
  "manual/rendering.html": {
    "href": "manual/rendering.html",
    "title": "Rendering | Engine4 Manual",
    "keywords": "Rendering [image] This rendering section covers built-in projections and visualizers, and giving you some idea about how to create custom one."
  },
  "manual/scripting.html": {
    "href": "manual/scripting.html",
    "title": "Scripting | Engine4 Manual",
    "keywords": "Scripting This scripting section consist of additional information required for manipulating Engine4 in runtime via scripting. For starting point, Engine4 exposes most of its modules as there are no compiled libraries included. Also, user can modify internal scripts at it own discretion."
  },
  "manual/modeling/modeler/custom.html": {
    "href": "manual/modeling/modeler/custom.html",
    "title": "Creating custom models | Engine4 Manual",
    "keywords": "Creating custom models You can create custom models by creating a script that deriving from Modeler4 using Engine4; using Engine4.Internal; using Engine4.Rendering; public class MyModel4 : Modeler4 { public override void CreateModel(Buffer4 buffer) { // Build a model here } } You can read more information related to Buffer4 here"
  },
  "manual/modeling/modeler/cylinder.html": {
    "href": "manual/modeling/modeler/cylinder.html",
    "title": "| Engine4 Manual",
    "keywords": "Cylinder4 [image] This component takes any kind of 3D mesh and extruding it overward in opposite direction to resemble a cylinder, but in any kind of surface shape. [demonstration]"
  },
  "manual/modeling/modeler/primitive.html": {
    "href": "manual/modeling/modeler/primitive.html",
    "title": "| Engine4 Manual",
    "keywords": "Primitive4 [image] This component creates four-dimensional regular shapes that has been long defined by mathematicians around the world. List of shapes Name # Cell Building Blocks Hyperplane 1 Cube Pentatope 5 Tetrahedron | Tesseract | 8 | Cube | | Hexdecahedroid | 16 | Tetrahedron| | Icosatetrahedroid | 24 | Dual-pyramid | | Hecatonicosahedroid | 120 | Dodecahedron | | Hexacosideroid | 600 | Tetrahedron | Tip There are lot websites explaining the detail of each shapes, for example click here ."
  },
  "manual/modeling/modeler/sphere.html": {
    "href": "manual/modeling/modeler/sphere.html",
    "title": "| Engine4 Manual",
    "keywords": "Sphere4 [image] Scripting definition This is a coordinate, polar based sphere. The coordinate function follows: [sourcefunction] There also an adjustable extent, so you can create 4D cube, sphere, capsule, rounded cube from this simple component."
  },
  "manual/modeling/modifier/custom.html": {
    "href": "manual/modeling/modifier/custom.html",
    "title": "Custom Modifier | Engine4 Manual",
    "keywords": "Custom Modifier You can create custom models by creating a script that deriving from Modifier4 using Engine4; using Engine4.Internal; using Engine4.Rendering; public class MyModel4 : Modifier4 { public override void ModifyModel(Buffer4 buffer) { // Build a model here } } You can read more information related to Buffer4 here"
  },
  "manual/modeling/modifier/uvmapper.html": {
    "href": "manual/modeling/modifier/uvmapper.html",
    "title": "UV Mapper | Engine4 Manual",
    "keywords": "UV Mapper This component procedurally generate UVs for any model (even complex one!) so you don't have to. Warning This component is under work in progress and may generate incorrect UV for current state."
  },
  "manual/physics/colliders.html": {
    "href": "manual/physics/colliders.html",
    "title": "Colliders | Engine4 Manual",
    "keywords": "Colliders These are list of collider shapes that Engine4 supports. @Engine4.BoxCollider4 Box collider has extent. @Engine4.SphereCollider4 Sphere collider has radius. @Engine4.CapsuleCollider4 Capsule collider has radius and height."
  },
  "manual/physics/global.html": {
    "href": "manual/physics/global.html",
    "title": "Global | Engine4 Manual",
    "keywords": "Global The next section comes the global handling to the physics engine."
  },
  "manual/rendering/projection/custom.html": {
    "href": "manual/rendering/projection/custom.html",
    "title": "Custom Projection System | Engine4 Manual",
    "keywords": "Custom Projection System We are not sure if this article are necessary, but it is possible to define projections method other than frustum and cross-section by deriving from @Engine4.Rendering.Projection4 : [script] And modify this part of code: and in enum:"
  },
  "manual/rendering/projection/frustum.html": {
    "href": "manual/rendering/projection/frustum.html",
    "title": "| Engine4 Manual",
    "keywords": "Frustum4 Frustum projection projects higher dimensional object by making 'far' objects smaller. This kind of projection is what most people recognize as what is 4D objects looks like. Visualization Depedency When renderer need # (visualization type) It needs # (simplex shape) Particle Point Wire Line Solid Triangle Properties Name Description Perspectiveness Orthographic to Perspective interpolation Focal length Inverse tangent of the FOV angle Near clip Nearest possible vertex distance before clipped Far clip Furthest possible vertex distance before clipped Shift clip Underward camera location offset relative to pivot Use Frustum Culling If yes, vertex will be culled using frustum cones Demographic Demographic below explains the properties in graphics: Suitable Usage Frustum may better suited for educational or visual purposes, despite it may be more complicated than cross section. However building model for frustum is easier because it does not deal with Tetrahedron as it's a game changer for cross section."
  },
  "manual/rendering/visualizer/custom.html": {
    "href": "manual/rendering/visualizer/custom.html",
    "title": "Custom Visualizer | Engine4 Manual",
    "keywords": "Custom Visualizer Here's the snippet template for creating custom visualizer. using System; using UnityEngine; using Engine4; using Engine4.Rendering; public class CustomVisualizer : Visualizer4 { Buffer3 helper; public override SimplexMode WorkingSimplexCase { get { // change simplex mode you've expected here return SimplexMode.Tetrahedron; } } public override void Clear(Mesh m) { // when renderer tells to clear buffer m.Clear(); } public override void End(Mesh m, VertexProfiles profile) { // when renderer tells to push helper.Apply(m, profile, MeshTopology.Triangles); } public override void Initialize(Buffer3 helper) { // whe renderer tells to get ready (this.helper = helper).Clear(); } public override void Render(VertexProfile[] buffer, int count) { // Do your stuff on profile } public override void Render(Vector4[] buffer, int count) { // Do your stuff } }"
  },
  "manual/rendering/visualizer/default.html": {
    "href": "manual/rendering/visualizer/default.html",
    "title": "Default Visualizers | Engine4 Manual",
    "keywords": "Default Visualizers [image] Default visualizers"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Engine4 Scripting Reference | Engine4 Manual",
    "keywords": "Engine4 Scripting Reference This section provides the documentation for all scripting members that documented through C# XML documentation. Either you use this documentation, or directly peek the code via intellisensing, the content are just the same! Engine4 API is divided into several namespaces... Engine4 Contains main engine classes and libraries. Engine4.Internal Contains shared extensions and utilities. Engine4.Physics Contains components that simulate runtime physics in 4D. Engine4.Rendering Contains built-in preset and libraries for certain tasks. Undocumented namespaces .... Engine4.Physics.Internal Contains the internal working of the physics engine. Engine4.Editing Contains editor tools and helper. Engine4.Examples Contains example classes and snippets."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Engine4 Manual v3.3 | Engine4 Manual",
    "keywords": ".centerImage { display: block; margin-left: auto; margin-right: auto; } Welcome to Engine4 Manual v3.3 Engine4 is a library that empowers the ability create four-dimensional scenes inside Unity Game Engine. We aim to develop this library with range of features so you can build more complex scenes without even think how it works. If you are new to Engine4 then continue reading below, otherwise you can click the Manual for usage instructions. The Main Goal Engine4 helps you to create four dimensional scenes inside Unity Game Engine, so you can focus on creating games, not the technical challenges, and think that 'everything' is upgradable to a higher dimension. If you have a plan to create four dimensional games, it's a lot better to start off from this library. There are some complex algorithms that you will never found anywhere else! The Secret Sauce The library is doing the runtime hardwork without external depedencies. Any input data that feeded into the library are processed into a projected shape that is renderable with conventional 3D rendering engines. Note that because Unity is a 3D Game Engine. Engine4 mostly do not use advanced features inside as it is limited to 3D space. Features Highlight Builtin Datatypes, Camera, Transformation, Rendering, Builder, Gizmo, Physics Library, etc. All operating in 4D. Shape building redefined: Make procedural creation easier for common scenarios. Full Scripting API and source code access without any compiled libraries. HTML based documentation with documented scripting APIs. Bundled with many scripting optimization in mind. Cross platform. Techically we can deploy to any device where unity supports. Limitations The development goal of Engine4 is to make the library have similar capabilities like most game engine have. Therefore, we put these honest limitation below as our TODOs for the next development of the library. No support for rendering via GPU/hardware acceleration. No particle system generator (although Engine4 does we have a particle renderer). Only limited set of shapes (cube, sphere, capsule) that supported by the Physics Engine. Physics Engine doesn't include joints and character controller. Building shapes can only done via procedural creations (FBX is for 3D model). No dedicated 4D graphics solution included (skybox, lighting, fog etc.) The documentation may unfinished or might have small grammar mistake. There are no real games published with this library so far. Known Issues These known issues is currently active in the latest version is listed here (sorted from the highest severety) and will be fixed in soon: Box to box collision are too aggresive (check Example/Scenes/CannonBox). Transform4 does not support multi selection. Helpful Links Asset Link | Online Documentation | Offline Documentation | Support Forum | Developer Website | Release Notes"
  },
  "manual/basics/4d.html": {
    "href": "manual/basics/4d.html",
    "title": "Wrapping your head into Fourth dimension | Engine4 Manual",
    "keywords": "Wrapping your head into Fourth dimension Fourth dimension in the nutshell is a new direction that always perpendicular to all direction in our 3D world. To avoid misconception, the fourth dimension that we use in this term are the fourth dimension in four dimensional euclidean space, not in the minkowski space-time! Starting point There are lot online websites explaining four-dimensional objects in detail. Have a look for these websites: eusebeia.dyndns.org Note This section does only cover information and concepts that specific to the library. We'll assume you have reading websites that has been linked above. Everything Upgradable The author of the library believes in Everything is Upgradable , means that anything that works in three or lower dimension can be implented in higher dimension, such as 4D. A very simple example can be inferred from the popular 4D shape tesseract , which is an upgrade from a cube , which is an upgrade from a square , and so on. image from wikipedia"
  },
  "manual/basics/components.html": {
    "href": "manual/basics/components.html",
    "title": "Components | Engine4 Manual",
    "keywords": "Components Engine4 has many components. In this section we'll discuss the primary purposes of each components."
  },
  "manual/basics/transform.html": {
    "href": "manual/basics/transform.html",
    "title": "Transform | Engine4 Manual",
    "keywords": "Transform Transform4 is the most crucial component as nearly all other Engine4 component depends on this. This component tells where the object's location belong to, as well as its rotation, etc."
  },
  "manual/basics/4d/deeper.html": {
    "href": "manual/basics/4d/deeper.html",
    "title": "Going deeper again | Engine4 Manual",
    "keywords": "Going deeper again You've learn about notation, projection, rotation in 4D and that's good enough for the starting point. You can extend your 4D understanding to scripting section. But for now it's better to continue to next section where it briefly discusses every component inside the library."
  },
  "manual/basics/4d/notation.html": {
    "href": "manual/basics/4d/notation.html",
    "title": "Notation and Convention Rules | Engine4 Manual",
    "keywords": "Notation and Convention Rules Engine4 is care about the conventions that used across the library to avoid confusion in the long run. The fourth axis The fourth axis is denoted by the letter W . This applies to whole library API. Additionally Engine4 uses overward for referencing a vector that points to W . The opposite vector may also be called as underward . Tip There also exist a paper that use the same term. See here . The Three-D part convention rules Engine4 honor the convention used in Unity Game Engine. The direction of each XYZ does not change, including the rotation axes, direction and its euler order. This means if rotation planes that related to W are set to zero, the object orientation will be the same with Unity. Rotation convention A rotation is happening on plane rotations. For simplicity, the library denote that to a single letter. Rotation on * plane Shortcoded as * YZ x XZ y XY z XW t YW u ZW v Rotation order and direction Euler to matrix conversion (and its inverse) codes are really different if the euler order are different. You make things clear, Engine4 defines Euler(Euler4) as conversion that creates matrix that rotates by y , then z , then x , then t , then u , then v . The rotation direction for x , y and z is preserved - clockwise based on axis perpendicular to each plane in 3D sense. For t , u , v is designed such at 90 positive deg rotation makes each 3D axis get replaced with positive over axis."
  },
  "manual/basics/4d/projection.html": {
    "href": "manual/basics/4d/projection.html",
    "title": "Projection in 4D | Engine4 Manual",
    "keywords": "Projection in 4D Projecting is a method to illustrate an object to dimension that is lower than the object itself. Projection of four-dimensional is quite challenging if you haven't heard it before. There are two projection methods that has been implemented in the library. Frustum Projection Frustum projection works like common camera games and our eye would - further objects get more smaller image. Frustum projection covers what would be commonly known as perspective and orthographic projection. If the object goes out of scope, it gets culled by a set of planes, which the process is commonly known as frustum culling . Tip There's a lot more features and cool tricks to be discovered. More info here . Cross section Projection Cross section takes a completely different way to project a higher dimension. Cross section does that by cutting an object and take the slice to lower dimension by rotating it back to an orientation that accesible with lower dimension objects. source If this kind of projection has been known for very long time why I didn't see any games have use it? Because you need to know how to cut down something into thing that renderable to 3D graphics (i.e. triangles). One way is to use tetrahedron as the building blocks. Why? Because tetrahedron is the simplest possible geometry shape that has a volume, and when it cutted, the result is always either a triangle or quad. source Tip Cross section is the default projection because its simplicity. More info here ."
  },
  "manual/basics/4d/rotation.html": {
    "href": "manual/basics/4d/rotation.html",
    "title": "Rotation in 4D | Engine4 Manual",
    "keywords": "Rotation in 4D Rotation in Engine4 is described as either euler or matrix. Rotation as Euler There are six planes of rotation in four dimension. They're denoted as x , y , z , t , u and v . The first three can be refered as 3D rotation part, and it is designed to be identical with rotations in 3D space. image in transform What's about the rest of three? t , u and v refers to rotation planes that related with the fourth axis, and X , Y , Z axis, in order. Rotation as matrix Four dimensional rotation can be representated as 4x4 order matrix. The main benefit is that matrices do not suffer from gimbal lock. Its detailed implementation is dissuced in the next article . No Quaternion Engine4 does not implement quaternion for 4D. Note that this does not mean it is impossible. Quaternion is upgradable to 4D using rotor concepts described in Geometry Algebra. The primary reason is that they do no longer provide its main benefit in computation cost. Cost comparison Primitive type Stored variable Multiplication cost Vector rotation cost 3D Quaternion 4 16 28 3D (3x3) Matrix 9 27 9 4D Quaternion 8 64 96 4D (4x4) Matrix 16 64 16 source From the comparison table, we can infer why using quaternion is useful than matrix in 3D space: Memory Storage is down by 55% Multiplication between quaternion is 1.69 times faster Even though quaternion multiplication with vector is costly, most people trick them by converting to matrix first (in optimized way) In 4D combining rotations has the same overhead, so the benefit is gone. Meanwhile, the quaternion to matrix in 4D is much much expensive than 3D (not to mention it is so complicated that nobody have published the code so far) so it is practically useless to bring quaternion to higher dimension. Futher explanation The next section discusses detailed convention used by the library. This article also extended to the scripting implementation for rotations."
  },
  "manual/basics/components/hierarchy.html": {
    "href": "manual/basics/components/hierarchy.html",
    "title": "Components in Hierarchy | Engine4 Manual",
    "keywords": "Components in Hierarchy There are lot of components for rendering inside Engine4. These components below always required in order a rendered and projected 4D object can be generated. Renderer4 Overloadable: No Lies in: Every 4D object Renderer4 manages when an object is required to be updated. When it happened, it instruct Modeler4 and other components to build the mesh buffer from stratch. Note that most operation is optimized (i.e. Modeler4 does not be called when changes only done in transformation) Modeler4 Overloadable: Yes Lies in: Every 4D object (can have multiple) Modeler4 decides what kind of shape that needs to be created. It's overloadable so you can create whatever kind of shape you can imagine. Modifier4 Overloadable: Yes Lies in: Every 4D object (optional) (can have multiple) Modifier4 modifies model generated by Modeler4 for specific, configurable behaviour. Transform4 Overloadable: No Lies in: Every 4D object Transform4 always required in every 4D object. the created mesh will be transformed before sending to Viewer4. Viewer4 Overloadable: No Lies in: Active Scene Viewer4 is the camera of Engine4. Only one Viewer4 is allowed in the scene. the created mesh is transformed again so it's relative to Viewer4. If no Viewer4 in the scene then one will be created automatically. Projector4 Overloadable: Yes Lies in: Active Scene (can have multiple) Projector4 projects the transformed 4D mesh. It is overloadable because there are [two projections] defined in Engine4. Visualizer4 Overloadable: Yes Lies in: Every 4D object (optional) Visualizer4 sends the projected 3D buffer to MeshFilter. The behaviour can be customized for more complex and fancy looking. It is optional because the default visualizer does not require to be attached in every 4D object. Summary"
  },
  "manual/basics/components/inheritance.html": {
    "href": "manual/basics/components/inheritance.html",
    "title": "Inheritance | Engine4 Manual",
    "keywords": "Inheritance From previous sections, we know that there are components that overloadable. Engine4 have made some of the derivations of these for very common task. The table below highlights derivations of these components. Modeler4 Component Summary Primitive4 Model regular 4D objects Sphere4 Model sphere-like objects Cylinder4 Model 4D cylinder from any 3D mesh Create custom model Modifier4 Component Summary - - Create custom modifier Visualizer4 Component Summary ParticleExtended4 Extended version of default particle visualizer SolidExtended4 Extended version of default solid visualizer Default visualizers Create custom visualizers Projector4 Component Summary Frustum4 Frustum projection CrossSection4 Cross section projection Note There is possibility to create custom projection method, however the world only knows two. Anyway if you wish so, click here . Collider4 Component Summary BoxCollider4 Box-shaped collider in 4D SphereCollider4 Sphere-shaped collider in 4D CapsuleCollider4 Capsule-shaped collider in 4D Note You can't create custom collider shape as our internal physics engine is fixed to these shapes."
  },
  "manual/basics/components/physics.html": {
    "href": "manual/basics/components/physics.html",
    "title": "Physics Components | Engine4 Manual",
    "keywords": "Physics Components Besides its rendering capacibility, Engine4 also have been equipped with dedicated four-dimensional physics simulation library. These components are required in order to make the physics simulation work for a given object. Rigidbody4 Overloadable: No Lies in: Every 4D object Rigidbody4 feeds collider and transform components to the internal engine and keep it in sync over fixed frame update. You can also change how the object react with its environment though its properties. Collider4 Overloadable: No Lies in: Every 4D object (can have multiple) Collider4 defines the rigid shape of a rigidbody. You can put a collider as the child of rigidbody. Physics4 Overloadable: No Lies in: Active Scene Physics4 is the head of the physics simulation. It lies together with Viewer4 . Disabling the component pauses all physics execution."
  },
  "manual/basics/transform/component.html": {
    "href": "manual/basics/transform/component.html",
    "title": "Component | Engine4 Manual",
    "keywords": "Component In summary Transform4 is like a 4D variant of UnityEngine's Transform component. You can set object's local position, rotation, and scale (if available) via inspector. You can also set it via scripting. 3D vs 4D While Unity requires every game object to have Transform , Transform4 doesn't. It only get added automatically when you add Engine4 components like Renderer4 or Rigidbody4 . Please note Transform and Transform4 are mutually exclusive and have nothing to do with each other. This also means you can mix between two values without problem at all. Warning We never recommend you to do that. Parenting Transform4 can handle parenting much like standard Transform . You even can put Transform4 inside to a parent which have no Transform4 at all. Warning There is a difference: (See the next section). Scaling Dilemma To avoid transformational problem, Transform4 doesn't apply scaling to its children. It is useful only for components that need it (e.g. Renderer4 and Collider ). If you didn't see scale in inspector, that's because none of object's components need Transform4 scale."
  },
  "manual/basics/transform/editing.html": {
    "href": "manual/basics/transform/editing.html",
    "title": "Transform4 in Editor | Engine4 Manual",
    "keywords": "Transform4 in Editor Editor Handle Engine4 editor is equipped with transformation handles to make 4D scenes easier to create. These editor can be activated via Transform4 component or these keyboard shortcuts: Shortcut Command shift + q Free mode | shift + w | Translate | | shift + e | Rotate | | shift + r | Scale, [if available] | Editor Navigation Transform4 also have a small applet for simple navigation. These xyzw buttons represents 90Â° rotation in T, U, V (the last is for identity rotation)."
  },
  "manual/extras/about.html": {
    "href": "manual/extras/about.html",
    "title": "About Engine4 | Engine4 Manual",
    "keywords": "About Engine4 Engine4 (c) Wildan Mubarok 2017. Engine4 is available as a managed library for Unity Game Engine . Engine4 Source is adhere to Unity Asset Store EULA . Engine4 Physics is powered by Zimpel Physics Engine (private repo at this state). Engine4 Documentation is powered by DocFX . Engine4 Documentation Content is adhere to CC-BY-3.0. Code Snippets can be copied freely without any credit. Engine4 Project is an ambitious, long-term project with incredible passion everything is upgradable . -- willnode"
  },
  "manual/extras/releasenotes.html": {
    "href": "manual/extras/releasenotes.html",
    "title": "Release Notes | Engine4 Manual",
    "keywords": "Release Notes V3.3 - Feb 28, 2018 This update comes with necessary updates for latest unity version NEW 32-bit mesh support for 2017.3 and above CHANGE Mark multithreading as experimental (hence disabled by default) FIX Compiler error and warning for Unity 2017 and 2018.1 FIX Don't generate dedicated rendering job unless it's turned on V3.2 - Nov 16, 2017 This update comes with fixes and correction for very basic yet important features. NEW Render in background thread. docs FIX Correction with physics angular velocity integration. FIX Incorrect Capsule and Box collision behaviour. FIX Correction for buit-in Transform4 vector axes. FIX 4D Gizmo randomly not applying position, color, matrices. V3.1 - Nov 1, 2017 This is the first stable release after very basic features has been corrected and implemented properly. Most APIs have been documented by this version. NEW Basic physics raycasting system NEW Physics Collision callback system NEW UV support, Tesseract and Hyperplane have UV implemented by default NEW Matrix4.LookAt, Matrix4.Delta NEW SimplexMode.Cubes IMPROVE Multi scene support IMPROVE Navigation UI now shows projection mode IMPROVE Transform4 position gizmo now follows local/global IMPROVE Primitive structs implements IEquatable to improve performance IMPROVE Projections uses array instead of List to improve performance IMPROVE Other several performance improvements FIX Debugger4 causes player build fail FIX Frustum culling get weird behaviour if too close FIX Possible null exception on parenting system FIX Physics forces discarded if done at init FIX Matrix4.ToEuler sigularities CHANGE Buffer4 profiles now applies to simplex index (indice) instead of vertices. Making vertex profiles should easier now. CHANGE Solid visualizer now must able handle polygon-like vertices CHANGE Moving physics component into Engine4.Physics and internal physics engine into Engine4.Physics.Internal V3.0 (Beta) - Oct 10, 2017 Mesh 4D Engine -> Engine4 V3.0 upgrade fully rewrites the library with more modular approach, better rendering system, including the brand new physics engine. The previous two diverse system now merged to one. Starting from this version the documentation have been improved as html-based. The version released as beta as few features haven't been finished. V2.2 - Aug 19, 2017 NEW SU4Cylinder to upload mesh to S4! NEW Adjustable 4th view position at S4 View Shortcut NEW S4 Primitive shape: 24-cell, 120-cell, 600-cell NEW Default material is assigned every time S4 Renderer added to a gameobject NEW Quaternion4.LookRotation, Matrix5x5.Transpose CHANGE deleting Viewer world/projection functions, use matrix instead FIX Corrected Quaternion4 multiplication FIX Improved Transform4 scale & rotation handle editor V2.1 - Jun 30, 2017 NEW Transform4 handle editor NEW Viewer world/projection converter APIs NEW Matrix5x5 inverse, TRS, MultiplyVector/Point4x5 NEW Vector5 struct (for Matrix5x5) NEW Global TRS API for Transform4 NEW V3Helper support multiple submesh NEW Culling and Better FOV for M4 projection NEW Culling for S4 for better performance CHANGE M4Renderer now always calculate lighting and added VertexProfiles. CHANGE M4Buffer uses V3Helper instead raw mesh to keep data. FIX Small performance optimizations V2.0 - Jun 4, 2017 Mesh 4D Engine and Morpher -> Mesh 4D Engine V2.0 upgrade fully rewrites the library with the first, real four-dimensional manipulation with basic procedural techniques. The workflow split to two for fulfilling two different projection types. The old code has been preserved as legacy V1.2 - Feb 6, 2016 NEW Baking system is now done automatically CHANGE autoUpdate property is now deprecated CHANGE Bake button is now deleted as being unnecessary CHANGE MeshRenderer is now included as component requirement FIX Bug introduced in 1.1.1 where the editor not updating properly V1.1.1 - Jan 25, 2016 Unity 5.6 Support V1.1 - Apr 28, 2015 Unity 4.6 Support. Faster Baking Time. Faster Calculation. Fix Morph update at runtime. Better Asset Management Added Additive RGB Shader (Particles/RGB Cube) V1.0 - Apr 21, 2015 The initial V1.0 introduces mesh-deformer that looks a like 4D shapes being transformed in 4D space."
  },
  "manual/modeling/buffer.html": {
    "href": "manual/modeling/buffer.html",
    "title": "Buffer | Engine4 Manual",
    "keywords": "Buffer Buffer4 contains a lot of predefined functions to help you build model easier than you ever though before."
  },
  "manual/modeling/modeler.html": {
    "href": "manual/modeling/modeler.html",
    "title": "Modeler Components | Engine4 Manual",
    "keywords": "Modeler Components Modeler creates the model procedurally from stratch. It is designed to be easy and cache-friendly so you can create whatever complex the shape you want. Engine4 also has built-in modeler for very basic geometries. You can peek the source code (it's well documented) to give you some ideas how we built them."
  },
  "manual/modeling/modifier.html": {
    "href": "manual/modeling/modifier.html",
    "title": "Modifier Components | Engine4 Manual",
    "keywords": "Modifier Components Aside from Modeler, Modifier modifies objects created by the modeler. You can make custom modifier to create behaviours to the model (for example, uv generator or mesh deformations). Modifiers are designed to be modular and animatable during runtime changes."
  },
  "manual/modeling/buffer/profiles.html": {
    "href": "manual/modeling/buffer/profiles.html",
    "title": "Profiles | Engine4 Manual",
    "keywords": "Profiles Profile is a way to add vertex metadata (i.e. color and uv ) and can be done via AddProfile(VertexProfile) or SetProfile(Int32, Color) or SetProfile(Int32, Vector4, Int32) . Note Buffer profiles are discarded when @Engine4.Buffer4.ProfileDifference is not 0 or profile profile is set to none UV Specification Engine4 treats UVs based on their simplex type: Simplex type UV dimension Point 0D Line 1D Triangle 2D Tetrahedron 3D [demographic] These specification is important as each Engine4 projector treat UVs differently: Frustum4 interpolate all UVs if it culled by frustum cone. CrossSection4 projects UV (eg. 3D to 2D for solid projection). This didn't happen for UV3 (so user may use that for shader effects)."
  },
  "manual/modeling/buffer/sequencer.html": {
    "href": "manual/modeling/buffer/sequencer.html",
    "title": "Sequence | Engine4 Manual",
    "keywords": "Sequence Besides Building Blocks, Buffer4 has another concept called Sequence . To access this feature, make sure the script header contains: using Engine4.Internal; // Sequencer (and other tools) is an extension method inside this namespace Example Suppose you want to create a looping lines that connects 20 vertices. public override void CreateModel(Buffer4 buffer) { for(int i = 0; i < 20; i++) buffer.AddVertex(new Vector4(i,0,0,0)); // create vertex for(int i = 0; i < 20; i++) buffer.AddSegment(i, (i + 1) % 20); // clever, doesn't it? } Instead of loop, you can simplify the segment creation with a single line. buffer.Sequence(SequenceMode.LineLoop); // cool! This is one of many sequencing presets . Grid Sequence With GridSequence Creating grid based model become a lot easier. public override void UploadBuffer(Buffer4 buffer) // creating tesseract { for(int x = -1; x <= 1; x+=2) for(int y = -1; y <= 1; y+=2) for(int z = -1; z <= 1; z+=2) for(int w = -1; w <= 1; w+=2) buffer.AddVertex(new Vector4(x,y,z,w)); // create vertex buffer.SequenceGrid(2, 2, 2, 2); // Done! } Direct Sequence C# have params which in turn gives power for lazy developers to get things done beautifully. In another words, this allows you to call multiple AddXXX() in single call. public override void UploadBuffer(Buffer4 buffer) // Read from mesh { Mesh mesh = GetComponent<MeshFilter>().sharedMesh; // get mesh buffer.AddVertex(Array.Convert(mesh.vertices, (v) => (Vector4)v)); // push vertices buffer.AddTriangle(mesh.triangles); // push triangles } If these building blocks doesn't fit to your case, you can directly sequence over params by calling AddBySequence . buffer.AddBySequence(SequenceMode.LineLoop, a, b, c, d, e, f, g, h, x, x, x); // Do whatever you like to do Note While params usage may impacting performance, it actually doesn't. In most cases Modeler4 only be called [once] per scene lifetime."
  },
  "manual/modeling/buffer/simplexes.html": {
    "href": "manual/modeling/buffer/simplexes.html",
    "title": "Simplex | Engine4 Manual",
    "keywords": "Simplex The simplest shape that you can build for the N-dimension is called Simplex . Alternatively, every simplex-N has it own familiar name: #-Simplex Name 0-Simplex Point 1-Simplex Segment 2-Simplex Triangle 3-Simplex Tetrahedron Why this is matter? While 3D mesh are built with either points, segments or triangles, Buffer4 will allow you to create models from many tethrahedron . The benefit is not just stop there, if you have seen Renderer4 then you know this legit dropdown: visualizerchoices Can generate the same shapes, but in different simplexes: visualizerinaction This can happen because in very basic level All Modeler4 should be restricted by its simplex mode : public override void UploadBuffer(Buffer4 buffer) { // Build vertices here: buffer.AddVertex() switch(buffer.simplex) // The buffer mode is determined internally based on the selected visualization mode { case SimplexMode.Point: /* build the model based on points: buffer.AddPoint() */ break; case SimplexMode.Segment: /* build the model based on segments: buffer.AddSegment() */ break; case SimplexMode.Triangle: /* build the model based on triangles: buffer.AddTriangle() */ break; case SimplexMode.Tetrahedron: /* build the model based on tetrahedrons: buffer.AddTrimid() */ break; } } Building Blocks To make building model easier (despite the fact buffer.simplex may make things harder), Buffer4 uses a better way to build a model, that is based on Building Blocks . In short summary you may use AddPoint() AddSegment() AddTriangle() AddTrimid() for each matching SimplexMode , but assuming these as a builing blocks, you can cross-use the functions together. Cross-use benefits Suppose you write this code: public override void UploadBuffer(Buffer4 buffer) { buffer.AddVert(new Vector4(0,0,0,0)); buffer.AddVert(new Vector4(1,0,0,0)); buffer.AddVert(new Vector4(2,0,0,0)); buffer.AddTriangle(0, 1, 2); // vertex index } oh my bad, I didn't follow guideline. Should I fix it? Not necessarily. Engine4 will adapt the code. This code: buffer.AddTriangle(0, 1, 2); // vertex index Is logically turned to this if buffer.simplex is SimplexMode.Point : buffer.AddPoint(0); // vertex index buffer.AddPoint(1); // vertex index buffer.AddPoint(2); // vertex index Or better yet, SimplexMode.Segment : buffer.AddPoint(0, 1); // vertex index buffer.AddPoint(1, 2); // vertex index buffer.AddPoint(2, 0); // vertex index This is because a triangle can be breaked down into segments or points . Engine4 will adapt the code for you. However this didn't apply if buffer.simplex is higher in dimension than the shape itself: // How do you logically break triangles to tetrahedron? (no idea) If this happen, it simply does nothing. Better Building Blocks In addition to four primitive shapes, Buffer4 also has been equipped with additional common shapes to make things easier: AddQuad AddPyramid AddPrism AddCube AddPolygon There's more here The illustration below explains the vertex sequence that should be follow for these additional building blocks: Why need Tetrahedron? Because cross section projection requires one higher level of given simplex mode. ( more info here ). This means while Frustum4 requires the same level (e.g. Solid -> Triangle ), CrossSection4 does need its higher level (e.g. Solid -> Tetrahedron )."
  },
  "manual/physics/rigidbody.html": {
    "href": "manual/physics/rigidbody.html",
    "title": "Rigidbody | Engine4 Manual",
    "keywords": "Rigidbody Rigidbody manages and control each object transform."
  },
  "manual/physics/global/collisioncallback.html": {
    "href": "manual/physics/global/collisioncallback.html",
    "title": "Collision Callback | Engine4 Manual",
    "keywords": "Collision Callback Engine4 physics have its own collision callback, though it's require you to have more little setup. Also see CollisionHit4 and @Engine4.Physics4.Collider4.callback . class MyComponent : MonoBehaviour4 { void OnEnable() { // Register GetComponent<Collider4>().callback += OnCollisionCallback; } void OnDisable() { // Unregister GetComponent<Collider4>().callback -= OnCollisionCallback; } void OnCollisionCallback (CollisionHit4 collision) { // Do something when this collider hit } }"
  },
  "manual/physics/global/configuration.html": {
    "href": "manual/physics/global/configuration.html",
    "title": "Configuration | Engine4 Manual",
    "keywords": "Configuration You can change the global configuration by modifying constant values in Assets\\Plugin\\Engine4\\Physics\\Common.cs . Each parameter has been annotated here . Note While there are many options available. By design, only @Engine4.Physics.Common.gravity that can be changed via script in runtime."
  },
  "manual/physics/global/raycast.html": {
    "href": "manual/physics/global/raycast.html",
    "title": "Raycast | Engine4 Manual",
    "keywords": "Raycast Basic raycasting can be done by calling @Engine4.Physics.Physics4.Raycast(Engine4.Physics.RaycastHit4). You can get Physics4 easily with physics4 when deriving your mono from MonoBehaviour4 . RaycastHit4 hit = physics4.Raycast(new Ray4(transform4.position, transform4.overward)); if (hit.hit) { // Raycast succeeded! }"
  },
  "manual/rendering/background.html": {
    "href": "manual/rendering/background.html",
    "title": "Background Rendering | Engine4 Manual",
    "keywords": "Background Rendering As of v1.2 Engine4 is capable to run rendering on background threads. To activate it, you need to check the Background checkbox in Viewer4 inspector. How it Works Every time an object need to update its projected 3D shape, they compute it directly in Unity's Update() call. This behaviour however is not optimal, as all Unity's operation is synchronous. However we have the solution. If background rendering is activated, all computational load in every 4D object get transferred in single object, namely a render worker. This worker then activate threads that will solve the computation. It will run as a completely different thread so it can run without pausing Unity's rendering process. The solved computation then sent back to each renderer and renderer itself only need to push the load into their mesh in another Update() call. The process above is repeated every time when a change is detected as long as the system active. Pros Asynchonous . Your FPS will never be impacted (hence constant) no matter how expensive is the overall operation. Multi-threading in mind. All CPU cores will be fully utilized. And can run while unity is busy with their GPU workload. Increase in response . With extra CPU time 4D objects will be rendered faster especially with devices with many core available. Cons Late update . Because it's a background operation, the computed mesh is always outdated by atleast a frame behind. However this doesn't impact gameplay experience (e.g. physics and transform checking by scripts). Hard to debug . Because of above reason, you're likely to enable this feature only at builds Update Tearing . It's true that the rendering process will be fast, but if not fast enough the mesh can be outdated by several frames, and this can be vary on each objects, refering to what we call as tear in updates : [image]"
  },
  "manual/rendering/projection.html": {
    "href": "manual/rendering/projection.html",
    "title": "Projections | Engine4 Manual",
    "keywords": "Projections Engine4 has its own projection system so it can be feeded to graphics library as 3D model. Projections can be changed via Viewer4 property either via inspector or scripting."
  },
  "manual/rendering/visualizer.html": {
    "href": "manual/rendering/visualizer.html",
    "title": "Visualizer | Engine4 Manual",
    "keywords": "Visualizer Visualizer"
  },
  "manual/rendering/projection/crosssection.html": {
    "href": "manual/rendering/projection/crosssection.html",
    "title": "| Engine4 Manual",
    "keywords": "CrossSection4 Cross Section projection projects higher dimensional object by cutting it to a lower dimension. Most of the cases you'll see that the projected model is look like its downgraded version (e.g. tesseract -> cube ). Visualization Depedency When renderer need # (visualization type) It needs # (simplex shape) Particle Line Wire Triangle Solid Tetrahedron Properties This projection doesn't have any meaningful property. Suitable Usage Cross Section is suitable for games that likes to preserve 3D behaviour but allows the player to roam into 4th dimension as well. It's generally and computationally simpler than frustum projection. Tip Because of its simplicity, Cross Section is also considered the default projection mode for any new Viewer4."
  },
  "manual/rendering/visualizer/extended.html": {
    "href": "manual/rendering/visualizer/extended.html",
    "title": "Extended Visualizer | Engine4 Manual",
    "keywords": "Extended Visualizer"
  },
  "manual/scripting/begin.html": {
    "href": "manual/scripting/begin.html",
    "title": "Getting Started | Engine4 Manual",
    "keywords": "Getting Started These are our recommended pratices when working with scripting for Engine4. MonoBehaviour4 You can derive your custom script with MonoBehaviour4 to get quick shortcuts to core components such as transform4 , renderer4 , rigidbody4 , viewer4 . MonoBehaviour4 inherits Unity's MonoBehaviour so all scripting functionalities are preserved. using Engine4; public class MyComponent : MonoBehaviour4 { } Vector4 conflicts Yes, Engine4 define its own Vector4 as we need more function than what available to UnityEngine's Vector4. To solve name conflicts, we suggest to add this snippet to all scripts that access Engine4 functionalities: using Vector4 = Engine4.Vector4; Changing object transform Object transform can be changed like usual, via transform4 . transform4.position += Vector4.up * 10; See the next section for more information regarding to transform manipulation. Changing Renderer4/Modeler4/Modifier4 member or property Changing only its property simply won't work. You have to notify the renderer using @Engine4.Renderer4.SetDirty // make a change GetComponent<Primitive4>().radius = 2f; // notify renderer4.SetDirty(DirtyLevel.Model); Remember that changing object transformation doesn't require the code to call SetDiry as it's managed automatically behind the scene. transform4.position += Vector4.up * 10; // Done, no need to call SetDirty"
  },
  "manual/scripting/crossdot.html": {
    "href": "manual/scripting/crossdot.html",
    "title": "Cross and Dot operation | Engine4 Manual",
    "keywords": "Cross and Dot operation Dot operation in 4D Dot operation's main usage is not broken in higher dimension. It is still useful for find vector length or project a vector by another vector. Cross operation in 4D Unlike Dot, Cross product is flawed and no longer works for higher dimension. This is mainly because our mistake as 3D being living in 3D world, having the same number of axes and plane rotation, and historically naming these operations below to a similar name, simply because the function are the same in 3D, regardless the fact that each of these have really different meaning and purpose. Because higher dimension have different axes and plane rotation, cross operation is splitted to four definitions: Cross operation to find another vector Cross(Vector4, Vector4, Vector4) Cross operation to find rotation between two vector Cross(Vector4, Vector4) Cross operation to find rotated vector after rotation @Engine4.Euler4.Cross(Engine4.Euler4,Engine4.Vector4) Cross operation to combine rotation @Engine4.Euler4.Cross(Engine4.Euler4,Engine4.Euler4) Note Those differences are already known for a long time in mathematics world known as wedge operation in geometry algebra."
  },
  "manual/scripting/gizmos.html": {
    "href": "manual/scripting/gizmos.html",
    "title": "Gizmos | Engine4 Manual",
    "keywords": "Gizmos Engine4 have a gizmo solution specialized for drawing 4D objects in gizmo. Example usage are for displaying collider shapes in scene editor. In scripting, you can access via Gizmos4"
  },
  "manual/scripting/transform.html": {
    "href": "manual/scripting/transform.html",
    "title": "Transform Manipulation | Engine4 Manual",
    "keywords": "Transform Manipulation Basis Engine4 has several structs (primitive data types) to aid transform manipulation. Struct Description Usage Vector4 Four dimensional vector Storing direction and position Euler4 Six dimensional vector Storing rotation angles and velocities Matrix4 4x4 basis matrix Storing and manipulating rotations Matrix4x5 4x5 basis matrix Storing rotational and translational transform altogether Note Engine4 does not provide Quaternion altough it is possible in 4D. The primary reason is that they do no longer maintain its main benefit in 4D and higher dimension, and very complicated. See here . Working with Vector Vector is useful for translation and scaling between vectors. Working with Rotation The rule of thumb when working with rotation is always start with euler, then work with matrices, and try to never converting it back to euler. Where Euler is useful Euler is useful for storing a readable data. [image] You can also interpolate between rotation via @Engine4.Euler4.Lerp(Engine4.Euler4,Engine4.Euler4,System.Single), RotateToward or SmoothDampAngle . If you happen to interpolate the current rotation in matrix, try to convert to euler at once . This is necessary to avoid chaos. // In coroutine .... var current = transform4.eulerAngles; var target = new Euler4(4, 90); // 90 deg at T (XW plane) for(int i = 0; i < 20; i++) { transform4.eulerAngles = Euler4.Lerp(current, target, i / 20f); yield return null; } // Every update with SmoothDampAngle .... Euler4 current; Euler4 target = new Euler4(4, 90); // 90 deg at T (XW plane) Euler4 speed; void Start() { current = transform4.eulerAngles; } void Update() { current = Euler4.SmoothDampAngle(current, target, ref speed, 0.2f); } Where Matrix is useful Matrices is useful for rotating any vector. [code] And also for combining rotation because its multiplication has no problem with gimbal lock. Euler4 A = transform4.eulerAngles, B = new Euler4(4, 90); Euler4 euler = A + B; // Dont' do this! gimbal lock may happen! Matrix4 C = transform4.rotation, D = Matrix4.Euler4(4, 90); Matrix4 matrix = C * D; // No problem :) Where things work for both Euler and Matrix. If you want to inverse the rotation, you can use Transpose(Matrix4) or UnaryNegation(Euler4) [code] Where habits in 3D do not work in 4D and higher Angle around an axis is not exist because in 4D you need two vector (so do the pattern for higher dimension). Listening to transform change class MyComponent : MonoBehaviour4 { void OnEnable() { // Register transform4.update += OnTransformUpdate; } void OnDisable() { // Unregister transform4.update -= OnTransformUpdate; } void OnTransformUpdate () { // Do something when this transform changed } }"
  },
  "api/Engine4.Axis4.html": {
    "href": "api/Engine4.Axis4.html",
    "title": "Enum Axis4 | Engine4 Manual",
    "keywords": "Enum Axis4 Axis in enumeration public enum Axis4 Fields Name Description W W (fourth) axis X X (first) axis Y Y (second) axis Z Z (third) axis"
  },
  "api/Engine4.Bounds4.html": {
    "href": "api/Engine4.Bounds4.html",
    "title": "Struct Bounds4 | Engine4 Manual",
    "keywords": "Struct Bounds4 Representation for bounds in 4 public struct Bounds4 Constructors Bounds4(Vector4) Create a bound with zero center and given extent public Bounds4(Vector4 extent) Bounds4(Vector4, Vector4) Create a bound with given min and max position public Bounds4(Vector4 Min, Vector4 Max) Fields max Maximum position of the bound public Vector4 max min Minimum position of the bound public Vector4 min Properties center Center position of the bound public Vector4 center { get; } extent Extent (center to corner distance) of the bound public Vector4 extent { get; } infinite Returns a bound with negative infinity size public static Bounds4 infinite { get; } size Size (edge to edge distance) of the bound public Vector4 size { get; } zero Returns a bound with zero size and zero center public static Bounds4 zero { get; } Methods Allocate(Vector4) Expand the bound to given point public void Allocate(Vector4 pos) Clamp(Vector4) Returns a point that either inside or touching the bound public Vector4 Clamp(Vector4 point) Clip(Vector4) Returns a point that either outside or touching the bound public Vector4 Clip(Vector4 t) Combine(Bounds4, Bounds4) Combine two bounds public static Bounds4 Combine(Bounds4 a, Bounds4 b) Compare(Vector4, Bounds4, Bounds4) Compare which Bounds4 is the closest. Positive means L is closer public static float Compare(Vector4 center, Bounds4 l, Bounds4 r) Contains(Bounds4) Is this bound contains the whole cell of the other bound? public bool Contains(Bounds4 other) Contains(Vector4) Is this bound contains the given point public bool Contains(Vector4 point) Interpolate(Vector4) Interpolate two vector by T. public Vector4 Interpolate(Vector4 t) Remarks The interpolation is not clamped Intersect(Bounds4, Bounds4) Intersect two bounds public static Bounds4 Intersect(Bounds4 a, Bounds4 b) IsIntersecting(Bounds4, Bounds4) Determine if and only if A partially contains B public static bool IsIntersecting(Bounds4 a, Bounds4 b) IsIntersecting(Plane4) Is the plane hits part of the bound? public bool IsIntersecting(Plane4 plane) Raycast(Vector4, Vector4) Check if given ray is colliding with the bound public bool Raycast(Vector4 p, Vector4 d) Scale(Bounds4, Vector4) Scales the bound's extent public static Bounds4 Scale(Bounds4 b, Vector4 s)"
  },
  "api/Engine4.Buffer4.html": {
    "href": "api/Engine4.Buffer4.html",
    "title": "Class Buffer4 | Engine4 Manual",
    "keywords": "Class Buffer4 Temporary representation of 4D mesh public class Buffer4 Namespace Engine4 Inheritance System.Object Buffer4 Constructors Buffer4() Create an empty buffer public Buffer4() Buffer4(SimplexMode) Create an empty buffer public Buffer4(SimplexMode simplex) Fields m_Indices Internal simplex (indices) buffer. public int[] m_Indices m_IndicesCount public int m_IndicesCount Remarks Get internal indices count m_Profiles Internal vertex profile buffer (color, uv). public VertexProfile[] m_Profiles Remarks Vertex profile respects to indices, not vertices m_ProfilesCount public int m_ProfilesCount Remarks Get internal profiles m_Vertices Internal vertex buffer public Vector4[] m_Vertices m_VerticesCount public int m_VerticesCount Remarks Get internal vertices count offset A handy pointer to shift vertex buffer values relatively. public int offset Remarks It's very recommended to control this param using Align() instead. simplex The simplex type that required by the renderer. Useful if you want to create a custom shape blocks. public SimplexMode simplex Remarks Public for speed. ONLY SET WHEN ISEMPTY IS TRUE. Methods AddCube(Int32, Int32, Int32, Int32, Int32, Int32, Int32, Int32) Helper to add a cube from 8 existing verts index. A cube is constructed from 5 trimids, v0-v1-v2-v3 must be parallel (and in the same order) with v4-v5-v6-v7 public void AddCube(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7) AddPoint(Int32) Add an artbitrary point. public void AddPoint(int v0) AddPrism(Int32, Int32, Int32, Int32, Int32, Int32) Helper to add a triangular prism from 6 existing verts index. A prism is constructed from 3 trimids, v0-v1-v2 must be parallel (and in the same order) with v3-v4-v5 public void AddPrism(int v0, int v1, int v2, int v3, int v4, int v5) AddProfile(VertexProfile) Add a new profile to remaining indice public void AddProfile(VertexProfile profile) AddPyramid(Int32, Int32, Int32, Int32, Int32) Helper to add a pyramid from 5 existing verts index. A pyramid is constructed from 2 trimids, v0 is the tip, the rest is the base. public void AddPyramid(int v0, int v1, int v2, int v3, int v4) AddQuad(Int32, Int32, Int32, Int32) Add a flat quad. Must be either clockwise/counter-clockwise order. public void AddQuad(int v0, int v1, int v2, int v3) AddSegment(Int32, Int32) Add a segment. Order doesn't matter. public void AddSegment(int v0, int v1) AddTriangle(Int32, Int32, Int32) Add a flat triangle. Order doesn't matter. public void AddTriangle(int v0, int v1, int v2) AddTrimid(Int32, Int32, Int32, Int32) Add a trimid (triangle pyramid) with given vert indexs. Order doesn't matter. public void AddTrimid(int v0, int v1, int v2, int v3) AddVertex(Vector4) Add a vertex with default profile and return the index public int AddVertex(Vector4 vert) AddVertex(Int32) Duplicate vertex and return the cloned index public int AddVertex(int idx) Remarks Useful for sequencing operations Align() Move buffer forward to the end. public void Align() Remarks Align are handy if used together with bulk operations (e.g. Sequence(Buffer4, SequenceMode) ) Align(Int32) Move buffer toward the given snapshot. public void Align(int snapshot) Remarks Use Snapshot() to obtain snapshot at given position. See Also Snapshot() Clean() Clear and Clean memory traces. public void Clean() Clear() Clear the buffer. public void Clear() Clear(SimplexMode) Clear the buffer. public void Clear(SimplexMode mode) IsEmpty() Is the buffer empty? public bool IsEmpty() SetProfile(Int32, Color) Modify profile color at given indice index public void SetProfile(int index, Color color) SetProfile(Int32, Vector4, Int32) Modify profile uv at given indice index public void SetProfile(int index, Vector4 uv, int uvIndex) Snapshot() Send copy of current buffer position to be reused later. public int Snapshot() See Also Align(Int32) Extension Methods Buffer4Extension.AddBySequence(Buffer4, SequenceMode, Int32[]) Buffer4Extension.AddBySequence(Buffer4, SequenceMode, VertexProfile[]) Buffer4Extension.AddPoint(Buffer4, Int32[]) Buffer4Extension.AddSegment(Buffer4, Int32[]) Buffer4Extension.AddTriangle(Buffer4, Int32[]) Buffer4Extension.AddQuad(Buffer4, Int32[]) Buffer4Extension.AddTrimid(Buffer4, Int32[]) Buffer4Extension.AddPolygon(Buffer4, Int32[]) Buffer4Extension.AddVertex(Buffer4, Vector4[]) Buffer4Extension.CopyTo(Buffer4, Buffer4) Buffer4Extension.CopyTo(Buffer4, Buffer4, Boolean) Buffer4Extension.Transform(Buffer4, Matrix4x5) Buffer4Extension.Transform(Buffer4, Matrix4x5, Vector4) Buffer4Extension.Colorize(Buffer4, Color) Buffer4Extension.Sequence(Buffer4, SequenceMode) Buffer4Extension.Sequence(Buffer4, SequenceMode, Int32, Int32) Buffer4Extension.SequenceGrid(Buffer4, Int32, Int32, Int32, Int32) Buffer4Extension.AddProfile(Buffer4, VertexProfile, VertexProfile) Buffer4Extension.AddProfile(Buffer4, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddProfile(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddPoint(Buffer4, VertexProfile) Buffer4Extension.AddSegment(Buffer4, VertexProfile, VertexProfile) Buffer4Extension.AddTriangle(Buffer4, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddQuad(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddTrimid(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddPyramid(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddPrism(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Buffer4Extension.AddCube(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile)"
  },
  "api/Engine4.DirtyLevel.html": {
    "href": "api/Engine4.DirtyLevel.html",
    "title": "Enum DirtyLevel | Engine4 Manual",
    "keywords": "Enum DirtyLevel Kind of validation requested public enum DirtyLevel Fields Name Description Model Request model and modifier and transform and visualizer update Modifier Request modifier and transform and visualizer update None No update request Transform Request transform and visualizer update Visualizer Request visualizer update"
  },
  "api/Engine4.Internal.INeedTransform4Scale.html": {
    "href": "api/Engine4.Internal.INeedTransform4Scale.html",
    "title": "Interface INeedTransform4Scale | Engine4 Manual",
    "keywords": "Interface INeedTransform4Scale An empty interface to mark a component that it needs transform4 scale so it can be shown. public interface INeedTransform4Scale"
  },
  "api/Engine4.Internal.MeshPool.html": {
    "href": "api/Engine4.Internal.MeshPool.html",
    "title": "Class MeshPool | Engine4 Manual",
    "keywords": "Class MeshPool Stack list to generate resusable mesh public static class MeshPool Namespace Engine4.Internal Inheritance System.Object MeshPool Methods Get() Get the mesh public static Mesh Get() Release(Mesh) Release the mesh public static void Release(Mesh m)"
  },
  "api/Engine4.Internal.ProjectorJob.html": {
    "href": "api/Engine4.Internal.ProjectorJob.html",
    "title": "Class ProjectorJob | Engine4 Manual",
    "keywords": "Class ProjectorJob public class ProjectorJob : MonoBehaviour4 Namespace Engine4.Internal Inheritance System.Object MonoBehaviour4 ProjectorJob Constructors ProjectorJob() public ProjectorJob() Fields identifier public int[] identifier projectors public Projector4[] projectors units public Queue<ProjectUnit> units workers public Thread[] workers Methods AddJob(ProjectUnit) public void AddJob(ProjectUnit unit) Dispose() public void Dispose() Initialize<T>(T) public void Initialize<T>(T template)where T : Projector4 SyncProjector<T>(T) public void SyncProjector<T>(T template)where T : Projector4"
  },
  "api/Engine4.Internal.Runtime.html": {
    "href": "api/Engine4.Internal.Runtime.html",
    "title": "Class Runtime | Engine4 Manual",
    "keywords": "Class Runtime Utilities for handling Scene, Game objects, Unity-related task. public static class Runtime Namespace Engine4.Internal Inheritance System.Object Runtime Methods CopyComponent<T>(T, T, BindingFlags) Copy component values to another public static void CopyComponent<T>(T source, T dest, BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy) CreateGameObject<T>(String, HideFlags) Create a new GameObject with hideFlags public static T CreateGameObject<T>(string name, HideFlags flags) Destroy(Object) Safer way to destroy an object public static void Destroy(Object obj) Dump(Mesh) Dump Mesh to Readable CSV format public static string Dump(Mesh m) GetComponentFromParent<T>(Transform) Find a component starting from its parent public static T GetComponentFromParent<T>(Transform start)where T : class GetCurrentCamera() Get either main camera or scene camera. public static Transform GetCurrentCamera() GetOrAddComponent<T>(GameObject) Get or add a component public static T GetOrAddComponent<T>(GameObject gameObject)where T : Component TransferTransform3DTo4D(GameObject) Push 3D data to 4D public static void TransferTransform3DTo4D(GameObject g)"
  },
  "api/Engine4.Internal.SequenceMode.html": {
    "href": "api/Engine4.Internal.SequenceMode.html",
    "title": "Enum SequenceMode | Engine4 Manual",
    "keywords": "Enum SequenceMode Sequincing preset to define the order of indices public enum SequenceMode Remarks It's recommended to choose based on the simplex type See Also Sequence ( Buffer4 , SequenceMode ) Fields Name Description Cubes Individual Cubes: 0,1,2,3,4 - 0,5,6,7,8 ... 0,n-3,n-2,n-1,n CubeStrip Continous Cube: 0,1,2,3,4 - 0,5,6,7,8 ... 0,n-3,n-2,n-1,n LineFan Branched Segments: 0,1 - 0,2 - 0,3 ... 0,n LineLoop Continous Cycled Segments: 0,1 - 1,2 - 2,3 ... n,0 Lines Individual Segments: 0,1 - 2,3 - 4,5 ... n-1,n LineStrip Continous Segments: 0,1 - 1,2 - 2,3 ... n-1,n Points Individual Points: 0 - 1 - 2 - 3 ... n Polygon Branched Cycled Triangles: 0,1,2 - 0,2,3 ... 0,n,1 PrismFan Branched Prism: 2,3,0,5,4,1 - 6,7,0,9,8,1 ... n-3,n-2,0,n,n-1,1 PyramidFan Branched Pyramids: 0,1,2,3,4 - 0,5,6,7,8 ... 0,n-3,n-2,n-1,n Quads Individual Quads: 0,1,2,3 - 4,5,6,7 ... n-3,n-2,n-1,n QuadStrip Continous Quads: 0,1,3,2 - 2,3,5,4 ... n-3,n-2,n,n-1 TriangleFan Branched Triangles: 0,1,2 - 0,2,3 ... 0,n-1,n Triangles Individual Triangles: 0,1,2 - 3,4,5 ... n-2,n-1,n TriangleStrip Continous Triangles: 0,1,2 - 1,2,3 ... n-2,n-1,n TrimidFan Branched Trimids: 0,1,2,3 - 0,4,5,6 ... 0,n-2,n-1,n Trimids Individual Trimids: 0,1,2,3 - 4,5,6,7 ... n-3,n-2,n-1,n TrimidStrip Continous Trimids: 0,1,2,3 - 1,2,3,4 ... n-3,n-2,n-1,n"
  },
  "api/Engine4.Internal.Set-1.html": {
    "href": "api/Engine4.Internal.Set-1.html",
    "title": "Class Set<T> | Engine4 Manual",
    "keywords": "Class Set<T> public class Set<T> Namespace Engine4.Internal Inheritance System.Object Set<T> Constructors Set() public Set() Properties Count public int Count { get; } Item[Int32] public T this[int index] { get; } Methods Add(T) public void Add(T t) Clear() public void Clear() Contains(T) public bool Contains(T t) Contains(Int32) public bool Contains(int hash) Remove(T) public void Remove(T t)"
  },
  "api/Engine4.Physics.CapsuleCollider4.html": {
    "href": "api/Engine4.Physics.CapsuleCollider4.html",
    "title": "Class CapsuleCollider4 | Engine4 Manual",
    "keywords": "Class CapsuleCollider4 Collider with shape of capsule public class CapsuleCollider4 : Collider4, INeedTransform4Scale Namespace Engine4.Physics Implements INeedTransform4Scale Inheritance System.Object MonoBehaviour4 Collider4 CapsuleCollider4 Constructors CapsuleCollider4() public CapsuleCollider4() Fields height Height of the capsule public float height radius Radius of the capsule public float radius Implements INeedTransform4Scale"
  },
  "api/Engine4.Physics.Collider4.html": {
    "href": "api/Engine4.Physics.Collider4.html",
    "title": "Class Collider4 | Engine4 Manual",
    "keywords": "Class Collider4 Base class for all collider in Engine4 public abstract class Collider4 : MonoBehaviour4, INeedTransform4Scale Namespace Engine4.Physics Implements INeedTransform4Scale Inheritance System.Object MonoBehaviour4 Collider4 BoxCollider4 CapsuleCollider4 SphereCollider4 Remarks Unlike Unity, all colliders must have a rigidbody in the same gameobject or its parent. Otherwise, a static rigidbody is automatically generated when the game start. Constructors Collider4() protected Collider4() Properties callback Register collision callback to this shape public CollisionCallback callback { get; set; } material Physics material used during simulation public PhysicsMaterial4 material { get; set; } sensor Determine if this collider ignores collision impacts (aka. trigger collider) public bool sensor { get; set; } Implements INeedTransform4Scale"
  },
  "api/Engine4.Physics.Physics4.html": {
    "href": "api/Engine4.Physics.Physics4.html",
    "title": "Class Physics4 | Engine4 Manual",
    "keywords": "Class Physics4 The head of the physics simulation. public class Physics4 : MonoBehaviour4, IContactListener Namespace Engine4.Physics Inheritance System.Object MonoBehaviour4 Physics4 Constructors Physics4() public Physics4() Fields defaultMaterial Default material fallback for the scene. public PhysicsMaterial4 defaultMaterial Properties main Main physics manager public static Physics4 main { get; } Methods Raycast(Ray4) Globally cast raycast and return report public static RaycastHit4 Raycast(Ray4 ray)"
  },
  "api/Engine4.Physics.RaycastHit4.html": {
    "href": "api/Engine4.Physics.RaycastHit4.html",
    "title": "Struct RaycastHit4 | Engine4 Manual",
    "keywords": "Struct RaycastHit4 Raycasting information. public struct RaycastHit4 Constructors RaycastHit4(Ray4) Create and initialize the raycast. public RaycastHit4(Ray4 ray) RaycastHit4(Ray4, Single, Vector4, Int32) Create, initialize, and report the raycast. public RaycastHit4(Ray4 ray, float distance, Vector4 normal, int hash) Fields distance The distance to impact point public float distance hash The collider hash that hits public int hash normal The surface normal of the impact public Vector4 normal ray The ray that generates the raycast public Ray4 ray Properties collider The collider that hits public Collider4 collider { get; } hit Does raycasting succeeded? public bool hit { get; } point The world point to the impact public Vector4 point { get; } Methods Set(Single, Vector4, Int32) Report the raycast public void Set(float distance, Vector4 normal, int hash)"
  },
  "api/Engine4.Physics.html": {
    "href": "api/Engine4.Physics.html",
    "title": "Namespace Engine4.Physics | Engine4 Manual",
    "keywords": "Namespace Engine4.Physics Classes BoxCollider4 Four-dimensional box collider for physics simulation CapsuleCollider4 Collider with shape of capsule Collider4 Base class for all collider in Engine4 Common ConstantForce4 Constant Force Physics4 The head of the physics simulation. Rigidbody4 Rigidbody makes the object is participating in the physics simulations. SphereCollider4 Four-dimensional sphere collider for physics simulation Structs CollisionHit4 Impact informations during physics collision RaycastHit4 Raycasting information. Delegates CollisionCallback Delegate to notice collision impacts"
  },
  "api/Engine4.PhysicsMaterial4.html": {
    "href": "api/Engine4.PhysicsMaterial4.html",
    "title": "Class PhysicsMaterial4 | Engine4 Manual",
    "keywords": "Class PhysicsMaterial4 Additional configuration asset for 4D physics simulation public class PhysicsMaterial4 : ScriptableObject Namespace Engine4 Inheritance System.Object PhysicsMaterial4 Remarks This asset is to be attached with Collider4 components Constructors PhysicsMaterial4() public PhysicsMaterial4() Fields bounce Bounceness (how much energy is preserved) ratio during impact public float bounce density Density (uniform mass) of the object public float density friction Friction (how much energy is lost) ratio during contact public float friction Properties global Default physics material that is used for physics simulations public static PhysicsMaterial4 global { get; }"
  },
  "api/Engine4.Ray4.html": {
    "href": "api/Engine4.Ray4.html",
    "title": "Struct Ray4 | Engine4 Manual",
    "keywords": "Struct Ray4 Represent of a line that extends to infinity public struct Ray4 Constructors Ray4(Vector4, Vector4) Create new Ray. public Ray4(Vector4 origin, Vector4 direction) Fields direction Direction of the ray public Vector4 direction origin Starting position of the ray public Vector4 origin Methods GetPoint(Single) Get a point that travels for given distance public Vector4 GetPoint(float distance) Operators Multiply(Ray4, Single) The GetPoint's exotic alternative public static Vector4 operator *(Ray4 ray, float distance)"
  },
  "api/Engine4.Renderer4.html": {
    "href": "api/Engine4.Renderer4.html",
    "title": "Class Renderer4 | Engine4 Manual",
    "keywords": "Class Renderer4 Component to render and manage outputs from modelers public class Renderer4 : MonoBehaviour4, INeedTransform4Scale Namespace Engine4 Implements INeedTransform4Scale Inheritance System.Object MonoBehaviour4 Renderer4 Constructors Renderer4() public Renderer4() Fields profile Additional vertex properties to be included in this renderer public VertexProfiles profile visualization Simplex type that'll be generated public VisualizeMode visualization Properties modelers List of modeler public List<Modeler4> modelers { get; } modifiers List of modeler public List<Modifier4> modifiers { get; } Methods ReacquireModelers() Invalidate list of modeler public void ReacquireModelers() ReacquireModifiers() Invalidate list of modifier public void ReacquireModifiers() SetDirty(DirtyLevel) Set this renderer to be validated later. Set rebake if mesh reconstruction is needed public void SetDirty(DirtyLevel level) Implements INeedTransform4Scale"
  },
  "api/Engine4.Rendering.Frustum4.html": {
    "href": "api/Engine4.Rendering.Frustum4.html",
    "title": "Class Frustum4 | Engine4 Manual",
    "keywords": "Class Frustum4 Projection helper using Frustum technique. public class Frustum4 : Projector4 Namespace Engine4.Rendering Inheritance System.Object Projector4 Frustum4 Remarks Frustum behaves the same way as conventional game engine does. Manual . Constructors Frustum4() public Frustum4() Fields farClip Maximum projection distance limit public float farClip focalLength Focal length of the camera public float focalLength nearClip Minimum projection distance limit public float nearClip perspectiveness Transition between orthographic (0) and perspective (1) public float perspectiveness shiftClip Backward shift of the camera public float shiftClip Remarks It's equivalent to move camera in negative W direction useFrustumCulling Use additional frustum culling? public bool useFrustumCulling Properties fieldOfView Access the calculated field of view angle in degree public float fieldOfView { get; set; } Methods SimplexModeForVisualizing(SimplexMode) This method always return the same simplex mode. public override SimplexMode SimplexModeForVisualizing(SimplexMode mode) Overrides Projector4.SimplexModeForVisualizing(SimplexMode)"
  },
  "api/Engine4.Rendering.Gizmos4.html": {
    "href": "api/Engine4.Rendering.Gizmos4.html",
    "title": "Class Gizmos4 | Engine4 Manual",
    "keywords": "Class Gizmos4 General editing-aid when working for gizmos in 4D public static class Gizmos4 Namespace Engine4.Rendering Inheritance System.Object Gizmos4 Properties color Set the gizmo color used to draw next gizmos. public static Color color { get; set; } matrix Set the gizmo matrix used to draw all gizmos. public static Matrix4x5 matrix { get; set; } Methods DrawCube(Vector4, Vector4) Draw a solid box with center and size. public static void DrawCube(Vector4 center, Vector4 size) DrawFrustum(Vector4, Single, Single, Single, Single) Draw a camera frustum using the currently set Gizmos.matrix for it's location and rotation. public static void DrawFrustum(Vector4 center, float min, float max, float focal, float perspectiveness) DrawLine(Vector4, Vector4) Draws a line starting at from towards to public static void DrawLine(Vector4 from, Vector4 to) DrawRay(Vector4, Vector4) Draws a ray starting at from to from + direction public static void DrawRay(Vector4 from, Vector4 direction) DrawRay(Ray) Draws a ray starting at from to from + direction public static void DrawRay(Ray r) DrawSphere(Vector4, Single) Draws a solid sphere with center and radius. public static void DrawSphere(Vector4 center, float radius) DrawWireCube(Vector4, Vector4) Draw a wireframe box with center and size. public static void DrawWireCube(Vector4 center, Vector4 size) DrawWireSphere(Vector4, Single) Draws a wireframe sphere with center and radius. public static void DrawWireSphere(Vector4 center, float radius)"
  },
  "api/Engine4.Rendering.GizmosContainer4.html": {
    "href": "api/Engine4.Rendering.GizmosContainer4.html",
    "title": "Class GizmosContainer4 | Engine4 Manual",
    "keywords": "Class GizmosContainer4 Gizmo container for rendering gizmo in 4D public class GizmosContainer4 : MonoBehaviour4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 GizmosContainer4 Constructors GizmosContainer4() public GizmosContainer4() Fields solid Gizmo renderer for solid objects public GizmosRenderer4 solid wire Gizmo renderer for wire objects public GizmosRenderer4 wire Properties main Access to the main component of GizmoContainer4 public static GizmosContainer4 main { get; }"
  },
  "api/Engine4.Rendering.GizmosRenderer4.GizmoRendererType.html": {
    "href": "api/Engine4.Rendering.GizmosRenderer4.GizmoRendererType.html",
    "title": "Enum GizmosRenderer4.GizmoRendererType | Engine4 Manual",
    "keywords": "Enum GizmosRenderer4.GizmoRendererType public enum GizmoRendererType Fields Name Description None None Solid Solid Wire Wire"
  },
  "api/Engine4.Rendering.ParticleExtended4.html": {
    "href": "api/Engine4.Rendering.ParticleExtended4.html",
    "title": "Class ParticleExtended4 | Engine4 Manual",
    "keywords": "Class ParticleExtended4 Extended particle visualizer. public class ParticleExtended4 : Visualizer4, IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object MonoBehaviour4 Visualizer4 ParticleExtended4 Constructors ParticleExtended4() public ParticleExtended4() Fields size Size of particle public float size Properties WorkingSimplexCase Always return Point public override SimplexMode WorkingSimplexCase { get; } Overrides Visualizer4.WorkingSimplexCase Implements IVisualizer"
  },
  "api/Engine4.Rendering.ParticleVisualizer4.html": {
    "href": "api/Engine4.Rendering.ParticleVisualizer4.html",
    "title": "Class ParticleVisualizer4 | Engine4 Manual",
    "keywords": "Class ParticleVisualizer4 Default Engine4 visualizer for particles public class ParticleVisualizer4 : IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object ParticleVisualizer4 Constructors ParticleVisualizer4() public ParticleVisualizer4() Properties WorkingSimplexCase Always return Point public SimplexMode WorkingSimplexCase { get; } Implements IVisualizer"
  },
  "api/Engine4.Rendering.Primitive4.Shape.html": {
    "href": "api/Engine4.Rendering.Primitive4.Shape.html",
    "title": "Enum Primitive4.Shape | Engine4 Manual",
    "keywords": "Enum Primitive4.Shape Primitive shapes selections public enum Shape Fields Name Description Hecatonicosahedroid 120-cell Hexacosidedroid 600-cell Hexdecahedroid 16-cell Hyperplane 1-cell Icosatetrahedroid 24-cell Pentatope 5-cell Tesseract 8-cell"
  },
  "api/Engine4.Rendering.Primitive4.html": {
    "href": "api/Engine4.Rendering.Primitive4.html",
    "title": "Class Primitive4 | Engine4 Manual",
    "keywords": "Class Primitive4 Built-in modeler to create regular shapes in 4D. public class Primitive4 : Modeler4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Modeler4 Primitive4 Remarks See online resources [here] to learn more about regular shapes in 4D. Constructors Primitive4() public Primitive4() Fields radius Radius (size) of the model public float radius shape Selected shape to be generated public Primitive4.Shape shape See Also Primitive4.Shape"
  },
  "api/Engine4.Rendering.Projector4.html": {
    "href": "api/Engine4.Rendering.Projector4.html",
    "title": "Class Projector4 | Engine4 Manual",
    "keywords": "Class Projector4 Base class to handle projection from 4D to 3D public abstract class Projector4 : MonoBehaviour Namespace Engine4.Rendering Inheritance System.Object Projector4 CrossSection4 Frustum4 Constructors Projector4() protected Projector4() Methods IsCullable(SphereBounds4) For static objects, see if given object AABB can be culled out completely public abstract bool IsCullable(SphereBounds4 bound) Project(Buffer4, Matrix4x5, IVisualizer) Dynamic projection public abstract void Project(Buffer4 from, Matrix4x5 transform, IVisualizer to) Project(Vector4) Arbitrary (4D to 3D) point projection public abstract Vector3 Project(Vector4 v) Project(Vector4, out Boolean) Arbitrary (4D to 3D) point projection with cull verification public abstract Vector3 Project(Vector4 v, out bool culled) Setup(Matrix4x5) Called by the viewer to initialize the projction public abstract void Setup(Matrix4x5 viewer) SimplexModeForVisualizing(SimplexMode) Adapt to simplex requirement for this projection. public abstract SimplexMode SimplexModeForVisualizing(SimplexMode mode)"
  },
  "api/Engine4.Rendering.SolidExtended4.html": {
    "href": "api/Engine4.Rendering.SolidExtended4.html",
    "title": "Class SolidExtended4 | Engine4 Manual",
    "keywords": "Class SolidExtended4 Extended particle visualizer. public class SolidExtended4 : Visualizer4, IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object MonoBehaviour4 Visualizer4 SolidExtended4 Constructors SolidExtended4() public SolidExtended4() Fields refineNormals Make normal consistent public bool refineNormals smoothNormals Make normal smooth by merging vertices public bool smoothNormals Properties WorkingSimplexCase Always return Triangle public override SimplexMode WorkingSimplexCase { get; } Overrides Visualizer4.WorkingSimplexCase Implements IVisualizer"
  },
  "api/Engine4.Rendering.WireVisualizer4.html": {
    "href": "api/Engine4.Rendering.WireVisualizer4.html",
    "title": "Class WireVisualizer4 | Engine4 Manual",
    "keywords": "Class WireVisualizer4 Default visualizer for wires public class WireVisualizer4 : IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object WireVisualizer4 Constructors WireVisualizer4() public WireVisualizer4() Properties WorkingSimplexCase Always return Line public SimplexMode WorkingSimplexCase { get; } Implements IVisualizer"
  },
  "api/Engine4.Rendering.html": {
    "href": "api/Engine4.Rendering.html",
    "title": "Namespace Engine4.Rendering | Engine4 Manual",
    "keywords": "Namespace Engine4.Rendering Classes CrossSection4 Projection helper using Cross section technique. Cylinder4 Built-in modeler to create a cylinder. Debugger4 Useful debugging feature for diagnosing modeler Frustum4 Projection helper using Frustum technique. Gizmos4 General editing-aid when working for gizmos in 4D GizmosContainer4 Gizmo container for rendering gizmo in 4D GizmosRenderer4 Internal class to handle gizmo rendering in 4D Modeler4 Base class from custom 4D model creation. Modifier4 Base class from custom 4D model modifier. ParticleExtended4 Extended particle visualizer. ParticleVisualizer4 Default Engine4 visualizer for particles Primitive4 Built-in modeler to create regular shapes in 4D. Projector4 Base class to handle projection from 4D to 3D SolidExtended4 Extended particle visualizer. SolidVisualizer4 Default Engine4 triangle visualizer Sphere4 Built-in modeler to create a sphere in 4D. Visualizer4 Base class for custom visualizer WireVisualizer4 Default visualizer for wires Interfaces IVisualizer Inteface to the visualizer Enums Debugger4.IndiceGizmoShow What need to to be shown for indice? GizmosRenderer4.GizmoRendererType Primitive4.Shape Primitive shapes selections UvMapMethod UV map unwrapping methods"
  },
  "api/Engine4.SimplexMode.html": {
    "href": "api/Engine4.SimplexMode.html",
    "title": "Enum SimplexMode | Engine4 Manual",
    "keywords": "Enum SimplexMode Simplex contain points. Simplex count must be divisible by 1 public enum SimplexMode Fields Name Description Line Simplex contain line segments. Simplex count must be divisible by 2 Point Simplex contain points. Simplex count must be divisible by 1 Tetrahedron Simplex contain volume tetrahedrons. Simplex count must be divisible by 4 Triangle Simplex contain flat triangles. Simplex count must be divisible by 3"
  },
  "api/Engine4.Space4.html": {
    "href": "api/Engine4.Space4.html",
    "title": "Enum Space4 | Engine4 Manual",
    "keywords": "Enum Space4 Space relatives for transformations public enum Space4 Fields Name Description Self Transform is applied from the local coordinate of an object View Transform is applied from the projected three-dimensional world coordinate of an object World Transform is applied from the four-dimensional world coordinate of an object"
  },
  "api/Engine4.BodyType.html": {
    "href": "api/Engine4.BodyType.html",
    "title": "Enum BodyType | Engine4 Manual",
    "keywords": "Enum BodyType Type of a rigidbody public enum BodyType Fields Name Description DynamicBody The rigidbody is simulated like a real object KinematicBody The rigidbody only gives impact to other bodies StaticBody The rigidbody doesn't receive and react to any impact and forces"
  },
  "api/Engine4.Buffer3.html": {
    "href": "api/Engine4.Buffer3.html",
    "title": "Class Buffer3 | Engine4 Manual",
    "keywords": "Class Buffer3 Temporary representation of a 3D mesh public sealed class Buffer3 Namespace Engine4 Inheritance System.Object Buffer3 Constructors Buffer3() Create an empty buffer public Buffer3() Buffer3(Mesh) Create and import from a mesh public Buffer3(Mesh m) Buffer3(Mesh, Int32) Create and import from a mesh within given submesh index public Buffer3(Mesh m, int submesh) Fields m_Colors Color data public List<Color> m_Colors m_Tris Triangle or indices data public List<List<int>> m_Tris m_Uv0 First UV data public List<Vector4> m_Uv0 m_Uv2 Second UV data public List<Vector4> m_Uv2 m_Uv3 Third UV data public List<Vector4> m_Uv3 m_Verts Vertices data public List<Vector3> m_Verts Methods AddMesh(Mesh, Boolean, Int32) Import from a mesh public void AddMesh(Mesh m, bool mergeSubmesh = true, int subMeshIdx = -1) AddProfile(VertexProfile) Add a vertex profile public void AddProfile(VertexProfile p) AddProfile(IEnumerable<VertexProfile>) Add multiple vertx profiles public void AddProfile(IEnumerable<VertexProfile> p) AddTris(IEnumerable<Int32>) Add multiple indices public void AddTris(IEnumerable<int> i) AddTris(Int32) Add an indice public void AddTris(int i) AddTris(Int32, Int32) Add an indice to given submesh public void AddTris(int i, int subMesh) AddTris(Int32, Int32, Int32) Add triangle public void AddTris(int i, int j, int k) AddVert(IEnumerable<Vector3>) Add multiple vertices public void AddVert(IEnumerable<Vector3> v) AddVert(Vector3) Add a single vertex public void AddVert(Vector3 v) Append(Buffer3, Boolean, Int32) Combine with another buffer public void Append(Buffer3 v, bool mergeSubmesh, int startingSubmesh) Apply(Mesh, VertexProfiles, MeshTopology) Apply to the mesh with given policy public void Apply(Mesh m, VertexProfiles profile, MeshTopology topology) Clear() Clear the buffer public void Clear() SetSubmesh() Advance to the next submesh public void SetSubmesh() SetSubmesh(Int32) Set current submesh writing index public void SetSubmesh(int idx)"
  },
  "api/Engine4.CollisionState.html": {
    "href": "api/Engine4.CollisionState.html",
    "title": "Enum CollisionState | Engine4 Manual",
    "keywords": "Enum CollisionState Collision state of an impact public enum CollisionState Fields Name Description Enter Collision is just started Exit Collision have been ended Stay Collision is still happening"
  },
  "api/Engine4.Euler4.html": {
    "href": "api/Engine4.Euler4.html",
    "title": "Struct Euler4 | Engine4 Manual",
    "keywords": "Struct Euler4 Rotation unit on each plane in 4D public struct Euler4 : IEquatable<Euler4> Remarks Euler4 is basically a vector with 6 axis (plane), and can be manipulated like other vector. In most cases when dealing with 4D rotations, you'll use Euler4, since it can be represented as an euler rotation, or angular velocity of an object. Constructors Euler4(Int32, Single) Create an euler data with a value for given axis index. public Euler4(int axis, float value) Remarks See Item[Int32] for axis index. Other axis will set as zero by default Euler4(Single, Single, Single, Single, Single, Single) Create an euler data with given individual values. public Euler4(float x, float y, float z, float t, float u, float v) Euler4(Vector3, Vector3) Create an euler data with given individual values (with a pair of Vector3). public Euler4(Vector3 xyz, Vector3 tuv) Fields t XW Plane public float t u YW Plane public float u v ZW Plane public float v x YZ Plane public float x y ZX Plane public float y z XY Plane public float z Properties Item[Int32] Get or set a vector value in given axis index public float this[int i] { get; set; } Remarks Axis index in order: X, Y, Z, T, U, V tuv Get TUV part if the euler public Vector3 tuv { get; } xyz Get XYZ part of the euler public Vector3 xyz { get; } zero Euler with zero values public static Euler4 zero { get; } Methods Cross(Vector4, Vector4) Creates an euler rotation from two vector public static Euler4 Cross(Vector4 a, Vector4 b) Remarks This method is equivalent to the wedge operation between vector and vector in Geometry Algebra. It is used by internal physics engine. Dot(Euler4, Euler4) Get the dot product of the euler public static float Dot(Euler4 a, Euler4 b) LengthSq(Euler4) Get the squared length of the euler public static float LengthSq(Euler4 v) LerpAngle(Euler4, Euler4, Single) Interpolate euler rotation degree from A to B by T in each axes public static Euler4 LerpAngle(Euler4 a, Euler4 b, float t) Remarks This method does loop back from 360 to zero if that's necessary. The interpolation is not clampled. Operators Addition(Euler4, Euler4) Axis-wisely add two euler values public static Euler4 operator +(Euler4 lhs, Euler4 rhs) Division(Euler4, Single) Axis-wisely divide an euler values with a number public static Euler4 operator /(Euler4 lhs, float f) Equality(Euler4, Euler4) Equivalence check public static bool operator ==(Euler4 lhs, Euler4 rhs) Inequality(Euler4, Euler4) Inequivalence check public static bool operator !=(Euler4 lhs, Euler4 rhs) Multiply(Euler4, Euler4) Axis-wisely scale both euler. public static Euler4 operator *(Euler4 a, Euler4 b) Multiply(Euler4, Single) Axis-wisely scale an euler values with a number public static Euler4 operator *(Euler4 lhs, float f) Multiply(Single, Euler4) Axis-wisely scale an euler values with a number public static Euler4 operator *(float f, Euler4 lhs) Subtraction(Euler4, Euler4) Axis-wisely subtract two euler values public static Euler4 operator -(Euler4 lhs, Euler4 rhs) UnaryNegation(Euler4) Negate each euler axis public static Euler4 operator -(Euler4 lhs) Implements System.IEquatable<T> See Also ToEuler() UnityEngine.Rigidbody.angularVelocity"
  },
  "api/Engine4.Internal.Buffer4Extension.html": {
    "href": "api/Engine4.Internal.Buffer4Extension.html",
    "title": "Class Buffer4Extension | Engine4 Manual",
    "keywords": "Class Buffer4Extension Buffer4 extension helper and utilities public static class Buffer4Extension Namespace Engine4.Internal Inheritance System.Object Buffer4Extension Methods AddBySequence(Buffer4, SequenceMode, VertexProfile[]) Add by given sequence public static void AddBySequence(this Buffer4 buffer, SequenceMode mode, params VertexProfile[] v) AddBySequence(Buffer4, SequenceMode, Int32[]) Add by given sequence public static void AddBySequence(this Buffer4 buffer, SequenceMode mode, params int[] v) AddCube(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Helper to add a cube from 8 existing verts index. (profile) public static void AddCube(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3, VertexProfile v4, VertexProfile v5, VertexProfile v6, VertexProfile v7) AddPoint(Buffer4, VertexProfile) Add an artbitrary point. (profile) public static void AddPoint(this Buffer4 buffer, VertexProfile v0) AddPoint(Buffer4, Int32[]) Add points. public static void AddPoint(this Buffer4 buffer, params int[] v) AddPolygon(Buffer4, Int32[]) Add polygon points/wires/surfaces. public static void AddPolygon(this Buffer4 buffer, params int[] v) AddPrism(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Helper to add a triangular prism from 6 existing verts index. (profile) public static void AddPrism(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3, VertexProfile v4, VertexProfile v5) AddProfile(Buffer4, VertexProfile, VertexProfile) Add new profiles to remaining indice public static void AddProfile(this Buffer4 buffer, VertexProfile v0, VertexProfile v1) AddProfile(Buffer4, VertexProfile, VertexProfile, VertexProfile) Add new profiles to remaining indice public static void AddProfile(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2) AddProfile(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Add new profiles to remaining indice public static void AddProfile(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3) AddPyramid(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Helper to add a pyramid from 5 existing verts index. (profile) public static void AddPyramid(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3, VertexProfile v4) AddQuad(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Add a flat quad. (profile) public static void AddQuad(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3) AddQuad(Buffer4, Int32[]) Add quads. public static void AddQuad(this Buffer4 buffer, params int[] v) AddSegment(Buffer4, VertexProfile, VertexProfile) Add a segment. (profile) public static void AddSegment(this Buffer4 buffer, VertexProfile v0, VertexProfile v1) AddSegment(Buffer4, Int32[]) Add segments. public static void AddSegment(this Buffer4 buffer, params int[] v) AddTriangle(Buffer4, VertexProfile, VertexProfile, VertexProfile) Add a flat triangle. (profile) public static void AddTriangle(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2) AddTriangle(Buffer4, Int32[]) Add triangles. public static void AddTriangle(this Buffer4 buffer, params int[] v) AddTrimid(Buffer4, VertexProfile, VertexProfile, VertexProfile, VertexProfile) Add a trimid (triangle pyramid). (profile) public static void AddTrimid(this Buffer4 buffer, VertexProfile v0, VertexProfile v1, VertexProfile v2, VertexProfile v3) AddTrimid(Buffer4, Int32[]) Add trimids. public static void AddTrimid(this Buffer4 buffer, params int[] v) AddVertex(Buffer4, Vector4[]) Add multiple vertexes. public static int AddVertex(this Buffer4 buffer, params Vector4[] v) Remarks The returning value is the vertex index for the first vertex. Colorize(Buffer4, Color) Set a solid color (without uv) to remaining indices public static void Colorize(this Buffer4 buffer, Color color) CopyTo(Buffer4, Buffer4) Append buffer content to another buffer public static void CopyTo(this Buffer4 origin, Buffer4 dest) CopyTo(Buffer4, Buffer4, Boolean) Append or overwrite buffer content to another buffer public static void CopyTo(this Buffer4 origin, Buffer4 dest, bool overwrite) Sequence(Buffer4, SequenceMode) Automatically add vertices to indices buffer since last Align() using given sequencing preset. public static void Sequence(this Buffer4 buffer, SequenceMode mode) Sequence(Buffer4, SequenceMode, Int32, Int32) Automatically add vertices to indices buffer since last Align() using given sequencing preset. public static void Sequence(this Buffer4 buffer, SequenceMode mode, int start = 0, int count = -1) SequenceGrid(Buffer4, Int32, Int32, Int32, Int32) Special sequencing tool when dealing with 1D, 2D, 3D or 4D grid vertices. public static void SequenceGrid(this Buffer4 buffer, int x, int y = 1, int z = 1, int w = 1) Remarks Set the grid count in the parameter. The nested order is for(x) => for(y) => for(z) => for(w). the starting point is always from the last Align() Transform(Buffer4, Matrix4x5) Transform vertices since last Align() public static void Transform(this Buffer4 buffer, Matrix4x5 matrix) Transform(Buffer4, Matrix4x5, Vector4) Translate and Transform vertices since last Align() public static void Transform(this Buffer4 buffer, Matrix4x5 matrix, Vector4 center)"
  },
  "api/Engine4.Internal.Buffer4Template.html": {
    "href": "api/Engine4.Internal.Buffer4Template.html",
    "title": "Class Buffer4Template | Engine4 Manual",
    "keywords": "Class Buffer4Template Collection of premade, reusable primitive shapes public static class Buffer4Template Namespace Engine4.Internal Inheritance System.Object Buffer4Template Methods DrawCubeUV(Buffer4) Add basic cube UV profile public static void DrawCubeUV(Buffer4 buffer) DrawQuadUV(Buffer4) Add basic quad UV profile public static void DrawQuadUV(Buffer4 buffer) MakeHypercube(Buffer4, Vector4) Draw hypercube to the buffer public static void MakeHypercube(Buffer4 buffer, Vector4 extent) MakeHyperfrustum(Buffer4, Single, Single, Single, Single) Draw frustum to the buffer public static void MakeHyperfrustum(Buffer4 buffer, float min, float max, float focal, float perspectiveness) MakeHypersphere(Buffer4, Single, Int32) Draw subdividable hypersphere to the buffer public static void MakeHypersphere(Buffer4 buffer, float radius, int subdivision = 8) MakeHypersphereMeridians(Buffer4, Single, Int32) Draw hypersphere meridians to the buffer public static void MakeHypersphereMeridians(Buffer4 buffer, float radius, int subdivision = 24)"
  },
  "api/Engine4.Internal.Matrix4AsEulerAttribute.html": {
    "href": "api/Engine4.Internal.Matrix4AsEulerAttribute.html",
    "title": "Class Matrix4AsEulerAttribute | Engine4 Manual",
    "keywords": "Class Matrix4AsEulerAttribute Attach this attribute to a Matrix4 field so it will be shown as Euler rotation. [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)] public sealed class Matrix4AsEulerAttribute : Attribute, _Attribute Namespace Engine4.Internal Implements System.Runtime.InteropServices._Attribute Inheritance System.Object System.Attribute Matrix4AsEulerAttribute Constructors Matrix4AsEulerAttribute() public Matrix4AsEulerAttribute() Implements System.Runtime.InteropServices._Attribute"
  },
  "api/Engine4.Internal.Overloads.html": {
    "href": "api/Engine4.Internal.Overloads.html",
    "title": "Class Overloads | Engine4 Manual",
    "keywords": "Class Overloads A library contain duplicates, internally meant for speed and exotic users. public static class Overloads Namespace Engine4.Internal Inheritance System.Object Overloads Methods ComputeBasis(Vector4) public static Matrix4 ComputeBasis(Vector4 forward) See Also ComputeBasis(Vector4[])"
  },
  "api/Engine4.Internal.ProjectUnit.html": {
    "href": "api/Engine4.Internal.ProjectUnit.html",
    "title": "Struct ProjectUnit | Engine4 Manual",
    "keywords": "Struct ProjectUnit public struct ProjectUnit Constructors ProjectUnit(Buffer4, Matrix4x5, IVisualizer, Renderer4) public ProjectUnit(Buffer4 b, Matrix4x5 m, IVisualizer v, Renderer4 r) Fields buffer public Buffer4 buffer matrix public Matrix4x5 matrix renderer public Renderer4 renderer visualizer public IVisualizer visualizer"
  },
  "api/Engine4.Internal.Reflected.html": {
    "href": "api/Engine4.Internal.Reflected.html",
    "title": "Class Reflected | Engine4 Manual",
    "keywords": "Class Reflected Reflection utilities public static class Reflected Namespace Engine4.Internal Inheritance System.Object Reflected Methods ClearDevConsole() Clear Unity's console public static void ClearDevConsole() ExtractArrayFromList<T>(List<T>) Extract array from list public static Array ExtractArrayFromList<T>(List<T> list) SetIndices(Mesh, List<Int32>, MeshTopology, Int32, Boolean) Mesh.SetIndices with generic list variant public static void SetIndices(Mesh m, List<int> buffer, MeshTopology topology, int submesh, bool recalculate)"
  },
  "api/Engine4.Internal.Utility.html": {
    "href": "api/Engine4.Internal.Utility.html",
    "title": "Class Utility | Engine4 Manual",
    "keywords": "Class Utility Mathematical Utilities and Struct Extras public static class Utility Namespace Engine4.Internal Inheritance System.Object Utility Fields BoxVertices List of tesseract vertices permutations public static readonly Vector4[] BoxVertices QuadToTris Quad into Two triangles public static readonly int[] QuadToTris Methods AngleLoop(Single) Convert value range -pi to pi into 0 to 2pi public static float AngleLoop(float v) Atan2(Single, Single) Atan2 with better handling of near 0, 0 singularity public static float Atan2(float y, float x) Atan2AvoidPi(Single, Single) Atan2 with clear meaning that we don't want pi simply to avoid headache public static float Atan2AvoidPi(float y, float x) Clamp(Single, Single, Single) Clamp T between A and B public static float Clamp(float a, float b, float t) Clamp01(Single) Clamp T between 0 and 1 public static float Clamp01(float t) Clear<T>(Stack<T>, T) Clear and push a new item to the stack public static void Clear<T>(this Stack<T> stack, T item) CrossInterpolate(Vector4, Vector4) Internally do Plane4.Intersect(), then Vector4.Lerp() public static Vector4 CrossInterpolate(Vector4 x, Vector4 y) CrossInterpolate(Vector4, Vector4, out Single) Internally do Plane4.Intersect(), then Vector4.Lerp(), and make the phase out public static Vector4 CrossInterpolate(Vector4 x, Vector4 y, out float phase) Expand<T>(List<T>, Int32) Expand list capacity to given capacity target public static void Expand<T>(this List<T> list, int capacity) Expand<T, T2>(List<T>, List<T2>) Expand list capacity to what another list has public static void Expand<T, T2>(this List<T> list, List<T2> capacity) GetAverage(List<Vector3>) Get average value public static Vector3 GetAverage(this List<Vector3> v) GetBounding(Vector4[], Int32) Get bounding min-max public static Bounds4 GetBounding(this Vector4[] v, int count) GetValue<K, V>(Dictionary<K, V>, K, V) Get a unique hash from the vector public static V GetValue<K, V>(this Dictionary<K, V> dict, K key, V fallback) GiveSign(Vector4, Int32, Int32) Give sign to any nonzero vector elements public static Vector4 GiveSign(Vector4 v, int x, int y) GiveSign(Vector4, Int32, Int32, Int32) Give sign to any nonzero vector elements public static Vector4 GiveSign(Vector4 v, int x, int y, int z) GiveSign(Vector4, Int32, Int32, Int32, Int32) Give sign to any nonzero vector elements public static Vector4 GiveSign(Vector4 v, int x, int y, int z, int w) Hue() Get Hue variation in gradient public static Gradient Hue() Hue(Single) Get Hue variation public static Color Hue(float h) Invert(Single) Inverse function (x => 1 / x) public static float Invert(float i) Random() Next random integer public static int Random() RemoveFast<T>(List<T>, T) Quickly remove an item if list order doesn't matter. public static void RemoveFast<T>(this List<T> list, T item) SetW(Vector3, Single) Sets the w and return Vector4 public static Vector4 SetW(this Vector3 xyz, float w) Sign(Single) Sign function (x => x / Abs(x)) public static float Sign(float v) Remarks This function will never return zero compared with .NET Math Swap<T>(ref T, ref T) Swap two object public static void Swap<T>(ref T l, ref T r) Tidy(Euler4) Remove unnecessary trailing digits for debugging ease. public static Euler4 Tidy(Euler4 v) Tidy(Matrix4) Remove unnecessary trailing digits for debugging ease. public static Matrix4 Tidy(Matrix4 v) Tidy(Vector4) Remove unnecessary trailing digits for debugging ease. public static Vector4 Tidy(Vector4 v) Tidy(Single) Remove unnecessary trailing digits for debugging ease. public static float Tidy(float v) VectorToKey(Vector4) Get a unique hash from the vector public static int VectorToKey(Vector4 v) VectorToKey(Vector3) Get a unique hash from the vector public static int VectorToKey(Vector3 v)"
  },
  "api/Engine4.Internal.html": {
    "href": "api/Engine4.Internal.html",
    "title": "Namespace Engine4.Internal | Engine4 Manual",
    "keywords": "Namespace Engine4.Internal Classes Buffer4Extension Buffer4 extension helper and utilities Buffer4Template Collection of premade, reusable primitive shapes Matrix4AsEulerAttribute Attach this attribute to a Matrix4 field so it will be shown as Euler rotation. MeshPool Stack list to generate resusable mesh Overloads A library contain duplicates, internally meant for speed and exotic users. ProjectorJob Reflected Reflection utilities Runtime Utilities for handling Scene, Game objects, Unity-related task. Set<T> Utility Mathematical Utilities and Struct Extras Structs ProjectUnit Interfaces INeedTransform4Scale An empty interface to mark a component that it needs transform4 scale so it can be shown. Enums SequenceMode Sequincing preset to define the order of indices"
  },
  "api/Engine4.Matrix4.html": {
    "href": "api/Engine4.Matrix4.html",
    "title": "Struct Matrix4 | Engine4 Manual",
    "keywords": "Struct Matrix4 A 4x4 matrix to describe 4D rotations public struct Matrix4 : IEquatable<Matrix4> Remarks The matrix is represented in row major order. Most operation that available requires the matrix to be orthogonal. This should not be confused with Unity's Matrix4x4. Constructors Matrix4(Vector4) Create a diagonal matrix with given scaling value. public Matrix4(Vector4 scale) Matrix4(Vector4, Vector4, Vector4, Vector4) Create a matrix data with given individual values (in vector form). public Matrix4(Vector4 x, Vector4 y, Vector4 z, Vector4 w) Matrix4(Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single, Single) Create a matrix data with given individual values. public Matrix4(float a, float b, float c, float d, float e, float f, float g, float h, float i, float j, float k, float l, float m, float n, float o, float p) Fields ew Fourth row of the matrix public Vector4 ew ex First row of the matrix public Vector4 ex ey Second row of the matrix public Vector4 ey ez Third row of the matrix public Vector4 ez Properties Column0 First column of the matrix public Vector4 Column0 { get; set; } Column1 Second column of the matrix public Vector4 Column1 { get; set; } Column2 Third column of the matrix public Vector4 Column2 { get; set; } Column3 Fourth column of the matrix public Vector4 Column3 { get; set; } Diagonal Access the diagonal row of the matrix public Vector4 Diagonal { get; } identity Get an identity matrix public static Matrix4 identity { get; } Item[Int32] Get Nth-row of the matrix public Vector4 this[int index] { get; set; } Item[Int32, Int32] Get a matrix element at given position public float this[int row, int column] { get; set; } zero Get a zero matrix public static Matrix4 zero { get; } Methods Abs(Matrix4) Returns the absolute version of the matrix. public static Matrix4 Abs(Matrix4 m) Column(Int32) Get Nth column by index public Vector4 Column(int i) Remarks It's much better to use the getter property if the index is hard-coded Column(Int32, Vector4) Set Nth column by index public void Column(int i, Vector4 value) Remarks It's much better to use the setter property if the index is hard-coded Delta(Matrix4, Matrix4) Create rotation matrix that rotates from matrix with to matrix public static Matrix4 Delta(Matrix4 from, Matrix4 to) Delta(Vector4, Vector4) Create rotation matrix that rotates from direction with to direction public static Matrix4 Delta(Vector4 from, Vector4 to) Determinant(Matrix4) Get the determinant of the matrix public static float Determinant(Matrix4 m) Euler(Euler4) Convert degree euler to orthogonal matrix rotation. public static Matrix4 Euler(Euler4 rot) Euler(Int32, Single) Convert given degree rotation in given axis to orthogonal matrix rotation. public static Matrix4 Euler(int axis, float degree) Remarks This method is much optimized than Euler(new Euler4(axis, degree)) Euler(Single, Single, Single, Single, Single, Single) Convert degree euler to orthogonal matrix rotation individually. public static Matrix4 Euler(float x, float y, float z, float t, float u, float v) Remarks This creates a rotation matrix that rotates a point by Y, Z, X, T, U, then V. In that order. LookAt(Vector4) Get rotation matrix that rotates identity object to given overward axis public static Matrix4 LookAt(Vector4 overward) LookAt(Vector4, Vector4) Get rotation matrix that rotates identity object to given overward and forward axis public static Matrix4 LookAt(Vector4 overward, Vector4 forward) LookAt(Vector4, Vector4, Vector4) Get rotation matrix that rotates identity object to given overward and forward and upward axis public static Matrix4 LookAt(Vector4 overward, Vector4 forward, Vector4 upward) Remarks Forward and upward is a support direction, meaning they'll change if they're not perpendicular with overward. ToEuler() Convert matrix into euler degree rotation public Euler4 ToEuler() Remarks The method is not valid in 90 deg singularity (WIP). The method won't check for orthogonality. Transform(Matrix4, Matrix4) Perform a sandwich operation on B by A public static Matrix4 Transform(Matrix4 a, Matrix4 b) Remarks The product is a rotation of B that oriented relative to A coordinate axes Transpose(Matrix4) Returns the transposed version of the matrix. public static Matrix4 Transpose(Matrix4 m) Remarks When the matrix is orthogonal, it's equivalent as the inversed version of the matrix Operators Addition(Matrix4, Matrix4) Element-wisely add two matrices. public static Matrix4 operator +(Matrix4 lhs, Matrix4 rhs) Remarks This operation could make the matrix not orthogonal anymore Division(Matrix4, Matrix4) Inversely Multiply or combine rotations between two matrices. public static Matrix4 operator /(Matrix4 q, Matrix4 r) Remarks B * A / B returns A Division(Vector4, Matrix4) Multiply or rotate a vector by the inversed version of this matrix public static Vector4 operator /(Vector4 v, Matrix4 r) Equality(Matrix4, Matrix4) Check the equality between two matrices public static bool operator ==(Matrix4 a, Matrix4 b) Implicit(Matrix4 to Matrix4x4) Implicit conversion to Unity's Matrix4x4 public static implicit operator Matrix4x4(Matrix4 v) Implicit(Matrix4x4 to Matrix4) Implicit conversion from Unity's Matrix4x4 public static implicit operator Matrix4(Matrix4x4 v) Inequality(Matrix4, Matrix4) Check the inequality between two matrices public static bool operator !=(Matrix4 a, Matrix4 b) Multiply(Matrix4, Matrix4) Multiply or combine rotations between two matrices. public static Matrix4 operator *(Matrix4 lhs, Matrix4 rhs) Multiply(Matrix4, Vector4) Multiply or rotate a vector by this matrix public static Vector4 operator *(Matrix4 lhs, Vector4 rhs) Multiply(Matrix4, Single) Scales the matrix public static Matrix4 operator *(Matrix4 lhs, float f) Remarks This operation could make the matrix not orthogonal anymore Subtraction(Matrix4, Matrix4) Element-wisely subtract two matrices. public static Matrix4 operator -(Matrix4 lhs, Matrix4 rhs) Remarks This operation could make the matrix not orthogonal anymore Implements System.IEquatable<T>"
  },
  "api/Engine4.Matrix4x5.html": {
    "href": "api/Engine4.Matrix4x5.html",
    "title": "Struct Matrix4x5 | Engine4 Manual",
    "keywords": "Struct Matrix4x5 A 4x5 matrix to describe 4D transformation public struct Matrix4x5 Constructors Matrix4x5(Vector4, Matrix4) Create a new 4x5 matrix. public Matrix4x5(Vector4 position, Matrix4 rotation) Fields position Fifth column of the matrix, denoted as a translation vector. public Vector4 position rotation 4x4 part of the matrix, denoted as a rotational matrix. public Matrix4 rotation Properties forward Get the forward (Z+) axis of the transform public Vector4 forward { get; } identity Get a 4x5 identity matrix public static Matrix4x5 identity { get; } overward Get the overward (W+) axis of the transform public Vector4 overward { get; } rightward Get the right (X+) axis of the transform public Vector4 rightward { get; } upward Get the up (Y+) axis of the transform public Vector4 upward { get; } Methods Inverse(Matrix4x5) Inverse the matrix public static Matrix4x5 Inverse(Matrix4x5 t) ToTRS(Vector4) Convert to non-orthogonal matrix by applying a scale public Matrix4x5 ToTRS(Vector4 scale) Remarks Do not inverse or multiply any matrix produced using this method. Operators Division(Matrix4x5, Matrix4x5) Inversely combine two matrices public static Matrix4x5 operator /(Matrix4x5 u, Matrix4x5 t) Remarks The operation is designed such that A * B / B is equivalent to A. Division(Vector4, Matrix4x5) Inversely transforms a point. public static Vector4 operator /(Vector4 v, Matrix4x5 tx) Remarks This operation is equivalent to Inverse(matrix) * vector Multiply(Matrix4x5, Bounds4) Convert to OBB, transform, then wrap it inside AABB back public static Bounds4 operator *(Matrix4x5 t, Bounds4 u) Multiply(Matrix4x5, Matrix4x5) Combine two transformations. public static Matrix4x5 operator *(Matrix4x5 t, Matrix4x5 u) Remarks The operation is not commutative Multiply(Matrix4x5, Plane4) Transform the right-hand plane public static Plane4 operator *(Matrix4x5 tx, Plane4 p) Multiply(Matrix4x5, Vector4) Transforms a point public static Vector4 operator *(Matrix4x5 tx, Vector4 v) Remarks This operator does translate the vector, Otherwise you should only multiply with the rotational part of this 4x5 matrix."
  },
  "api/Engine4.MonoBehaviour4.html": {
    "href": "api/Engine4.MonoBehaviour4.html",
    "title": "Class MonoBehaviour4 | Engine4 Manual",
    "keywords": "Class MonoBehaviour4 Base class to get access with main Engine4 components public class MonoBehaviour4 : MonoBehaviour Namespace Engine4 Inheritance System.Object MonoBehaviour4 ProjectorJob Collider4 ConstantForce4 Physics4 Rigidbody4 Renderer4 Debugger4 GizmosContainer4 GizmosRenderer4 Modeler4 Modifier4 Visualizer4 Viewer4 Constructors MonoBehaviour4() public MonoBehaviour4() Properties physics4 Direct access to Physics4 public static Physics4 physics4 { get; } renderer4 Direct access to Renderer4 public Renderer4 renderer4 { get; } rigidbody4 Direct access to Rigidbody4 public Rigidbody4 rigidbody4 { get; } transform4 Direct access to Transform4 public Transform4 transform4 { get; } viewer4 Direct access to Viewer4 public static Viewer4 viewer4 { get; } Methods Instantiate(GameObject, Vector4, Matrix4) Instantiate with given four-dimensional position and rotation public static GameObject Instantiate(GameObject g, Vector4 position, Matrix4 rotation)"
  },
  "api/Engine4.Physics.BoxCollider4.html": {
    "href": "api/Engine4.Physics.BoxCollider4.html",
    "title": "Class BoxCollider4 | Engine4 Manual",
    "keywords": "Class BoxCollider4 Four-dimensional box collider for physics simulation public class BoxCollider4 : Collider4, INeedTransform4Scale Namespace Engine4.Physics Implements INeedTransform4Scale Inheritance System.Object MonoBehaviour4 Collider4 BoxCollider4 Constructors BoxCollider4() public BoxCollider4() Fields size Size (edge to edge distance) of the box public Vector4 size Implements INeedTransform4Scale"
  },
  "api/Engine4.Physics.CollisionCallback.html": {
    "href": "api/Engine4.Physics.CollisionCallback.html",
    "title": "Delegate CollisionCallback | Engine4 Manual",
    "keywords": "Delegate CollisionCallback Delegate to notice collision impacts public delegate void CollisionCallback(CollisionHit4 collision);"
  },
  "api/Engine4.Physics.CollisionHit4.html": {
    "href": "api/Engine4.Physics.CollisionHit4.html",
    "title": "Struct CollisionHit4 | Engine4 Manual",
    "keywords": "Struct CollisionHit4 Impact informations during physics collision public struct CollisionHit4 Constructors CollisionHit4(CollisionState) Internal quick constructor public CollisionHit4(CollisionState state) CollisionHit4(CollisionState, Contact, Boolean) Internal quick constructor public CollisionHit4(CollisionState state, Contact c, bool isForA) Fields manifold The internal access to the manifold public Manifold manifold other The other collider we are colliding with public Collider4 other sensor Is this a collision with other trigger? public bool sensor Remarks Trigger-trigger collision is not supported state The state of the collision public CollisionState state Properties depths The contact penetrations of the collision public float[] depths { get; } Remarks Use this param to get precise information about contact points normal The normal direction of the collision public Vector4 normal { get; } Remarks The returning direction is toward to other's body points The contact points of the collision public Vector4[] points { get; } Remarks The returning point is the average between two overlapping points"
  },
  "api/Engine4.Physics.Common.html": {
    "href": "api/Engine4.Physics.Common.html",
    "title": "Class Common | Engine4 Manual",
    "keywords": "Class Common public static class Common Namespace Engine4.Physics Inheritance System.Object Common Fields ALLOW_SLEEP Enables or disables rigid body sleeping. It's an important optimization on every physics engine. It's recommended to leave this on. public const bool ALLOW_SLEEP = true BAUMGARTE How fast the collision must be resolved? (Default is 0.2) public const float BAUMGARTE = 0.2F ENABLE_FRICTION When two objects lay on each other should the simulator simulate friction? It's recommended to leave this on. public const bool ENABLE_FRICTION = true GRAVITY Default gravity for all simulations. This parameter can be dynamically adjusted. public static Vector4 GRAVITY ITERATIONS Constant collision solving iteration. Higher values are more realistic, yet more expensive. Default is 15, can be put between 5 to 20 public const int ITERATIONS = 15 MAX_DT Maximum allowed delta time. This prevents objects bypassing each other because of too large delta time. (Default is 0.02) public const float MAX_DT = 0.02F MULTICONTACT_COUNT Constant maximum multi contact count. Don't change. public const int MULTICONTACT_COUNT = 16 PENETRATION_SLOP Offset of allowed contact depth before kicked out by the solver. Allow very small number to avoid jitter. (Default is 0.05) public const float PENETRATION_SLOP = 0.02F SIM_RANGE Simulation range helps to avoid wasted time computation of computing Objects that out of range (e.g. object keeps falling down). The object is deactivated once becomes so. public static readonly Bounds4 SIM_RANGE SLEEP_ANGULAR Maximum allowed angular velocity that makes a rigidbody sleeps (Default is 2 deg) public const float SLEEP_ANGULAR = 0.0349065848F SLEEP_LINEAR Maximum allowed linear velocity that makes a rigidbody sleeps (Default is 0.01) public const float SLEEP_LINEAR = 0.01F SLEEP_TIME Simulator don't make rigidbody sleeps instantly. They have a chance by given time to awake by itself. (Default is 0.5) public const float SLEEP_TIME = 0.5F Methods MixFriction(Shape, Shape) Friction (slide) mixing. Default is average public static float MixFriction(Shape A, Shape B) MixRestitution(Shape, Shape) Restitution (bounce) mixing. Default is max public static float MixRestitution(Shape A, Shape B)"
  },
  "api/Engine4.Physics.ConstantForce4.html": {
    "href": "api/Engine4.Physics.ConstantForce4.html",
    "title": "Class ConstantForce4 | Engine4 Manual",
    "keywords": "Class ConstantForce4 Constant Force public class ConstantForce4 : MonoBehaviour4 Namespace Engine4.Physics Inheritance System.Object MonoBehaviour4 ConstantForce4 Constructors ConstantForce4() public ConstantForce4() Fields angularForce Angular force to be applied each frame public Euler4 angularForce linearForce Linear force to be applied each frame public Vector4 linearForce"
  },
  "api/Engine4.Physics.Rigidbody4.html": {
    "href": "api/Engine4.Physics.Rigidbody4.html",
    "title": "Class Rigidbody4 | Engine4 Manual",
    "keywords": "Class Rigidbody4 Rigidbody makes the object is participating in the physics simulations. public class Rigidbody4 : MonoBehaviour4 Namespace Engine4.Physics Inheritance System.Object MonoBehaviour4 Rigidbody4 Remarks It's generally not a good idea if you put the same rigidbody in the same object, or in the parent, as both will change transformation together and causing deadlocks. Constructors Rigidbody4() public Rigidbody4() Properties angularDamping Angular damping of the body public float angularDamping { get; set; } angularVelocity Angular velocity of this rigidbody (radian/sec) public Euler4 angularVelocity { get; set; } gravityScale Amount of gravity that affects the body public float gravityScale { get; set; } linearDamping Linear damping of the body public float linearDamping { get; set; } linearVelocity Linear velocity of this rigidbody (world unit/sec) public Vector4 linearVelocity { get; set; } type Rigidbody type during simulation public BodyType type { get; set; } Methods AddForce(Vector4) Add a force public void AddForce(Vector4 force) Remarks A force is affected by delta time and mass and it is generally accumulated over time. AddForceAtPosition(Vector4, Vector4) Add force at position public void AddForceAtPosition(Vector4 force, Vector4 point) AddImpulse(Vector4) Add an impulse public void AddImpulse(Vector4 impulse) Remarks An impulse is not affected by delta time but mass and it is generally applied once. AddTorque(Euler4) Add torque (force in terms of rotation) public void AddTorque(Euler4 torque) Sleep() Set rigidbody to sleep public void Sleep() ToString(Boolean) Dump state to string for debugging ease. public string ToString(bool report) WakeUp() Wake up rigidbody if it sleeping public void WakeUp()"
  },
  "api/Engine4.Physics.SphereCollider4.html": {
    "href": "api/Engine4.Physics.SphereCollider4.html",
    "title": "Class SphereCollider4 | Engine4 Manual",
    "keywords": "Class SphereCollider4 Four-dimensional sphere collider for physics simulation public class SphereCollider4 : Collider4, INeedTransform4Scale Namespace Engine4.Physics Implements INeedTransform4Scale Inheritance System.Object MonoBehaviour4 Collider4 SphereCollider4 Constructors SphereCollider4() public SphereCollider4() Fields radius Size (center to edge distance) of the sphere public float radius Implements INeedTransform4Scale"
  },
  "api/Engine4.Plane4.html": {
    "href": "api/Engine4.Plane4.html",
    "title": "Struct Plane4 | Engine4 Manual",
    "keywords": "Struct Plane4 Mathematical abstraction of a plane that split spaces in 4D public struct Plane4 Constructors Plane4(Vector4, Vector4) Create a new plane with given normal at given point public Plane4(Vector4 norm, Vector4 point) Plane4(Vector4, Vector4, Vector4, Vector4) Create a new plane from known vertices public Plane4(Vector4 a, Vector4 b, Vector4 c, Vector4 d) Plane4(Vector4, Single) Create a new plane with given normal and distance public Plane4(Vector4 norm, float dist) Fields distance The distance of the plane public float distance normal The normal of the plane public Vector4 normal Properties origin Get origin of a plane public Vector4 origin { get; set; } Methods Distance(Vector4) Get distance between a point and the nearest point on a plane. public float Distance(Vector4 point) Remarks The method can return a negative value, which mean the point is behind the plae GetSide(Vector4) Is the point is above or behind the plane? public bool GetSide(Vector4 point) Intersect(Vector4, Vector4) Given an edge represented as two points, return an interpolation where the point intersects public float Intersect(Vector4 a, Vector4 b) Remarks The resulting interpolation is unclamped, can go beyond 0..1 Project(Vector4) Project the point to the nearest point on the plane. public Vector4 Project(Vector4 point) SameSide(Vector4, Vector4) Is the two point is in the same side of the plane? public bool SameSide(Vector4 a, Vector4 b)"
  },
  "api/Engine4.ProjectionMode.html": {
    "href": "api/Engine4.ProjectionMode.html",
    "title": "Enum ProjectionMode | Engine4 Manual",
    "keywords": "Enum ProjectionMode Projection modes public enum ProjectionMode See Also Viewer4 Fields Name Description CrossSection Cross Section Frustum Frustum"
  },
  "api/Engine4.Rendering.CrossSection4.html": {
    "href": "api/Engine4.Rendering.CrossSection4.html",
    "title": "Class CrossSection4 | Engine4 Manual",
    "keywords": "Class CrossSection4 Projection helper using Cross section technique. public class CrossSection4 : Projector4 Namespace Engine4.Rendering Inheritance System.Object Projector4 CrossSection4 Remarks Cross section project model by cutting it in half. Manual . Constructors CrossSection4() public CrossSection4() Methods SimplexModeForVisualizing(SimplexMode) This method always return the higher version from the simplex. public override SimplexMode SimplexModeForVisualizing(SimplexMode mode) Overrides Projector4.SimplexModeForVisualizing(SimplexMode)"
  },
  "api/Engine4.Rendering.Cylinder4.html": {
    "href": "api/Engine4.Rendering.Cylinder4.html",
    "title": "Class Cylinder4 | Engine4 Manual",
    "keywords": "Class Cylinder4 Built-in modeler to create a cylinder. public class Cylinder4 : Modeler4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Modeler4 Cylinder4 Remarks This component will copy the base mesh, duplicate, and extrude them overward, Resembling a 'cylinder', but with custom 'flat' mesh. Constructors Cylinder4() public Cylinder4() Fields height Height of the cylinder. public float height mesh The base mesh as cylinder's 'surface' public Mesh mesh radius Scale of the cylinder surface public float radius"
  },
  "api/Engine4.Rendering.Debugger4.IndiceGizmoShow.html": {
    "href": "api/Engine4.Rendering.Debugger4.IndiceGizmoShow.html",
    "title": "Enum Debugger4.IndiceGizmoShow | Engine4 Manual",
    "keywords": "Enum Debugger4.IndiceGizmoShow What need to to be shown for indice? public enum IndiceGizmoShow Fields Name Description Color Color. Index Index. None None. UV UV. UV2 UV2. UV3 UV3."
  },
  "api/Engine4.Rendering.Debugger4.html": {
    "href": "api/Engine4.Rendering.Debugger4.html",
    "title": "Class Debugger4 | Engine4 Manual",
    "keywords": "Class Debugger4 Useful debugging feature for diagnosing modeler public class Debugger4 : MonoBehaviour4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Debugger4 Constructors Debugger4() public Debugger4() Fields indiceGizmo Show kind of indice gizmo public Debugger4.IndiceGizmoShow indiceGizmo indiceLabel Show indice label public bool indiceLabel max Maximum filter public float max min Minimum filter public float min vertexGizmo Show vertex gizmo. public bool vertexGizmo vertexLabels Show vertex label. public bool vertexLabels"
  },
  "api/Engine4.Rendering.GizmosRenderer4.html": {
    "href": "api/Engine4.Rendering.GizmosRenderer4.html",
    "title": "Class GizmosRenderer4 | Engine4 Manual",
    "keywords": "Class GizmosRenderer4 Internal class to handle gizmo rendering in 4D public class GizmosRenderer4 : MonoBehaviour4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 GizmosRenderer4 Remarks The component works magically under the hood Constructors GizmosRenderer4() public GizmosRenderer4() Fields type The gizmo renderer type public GizmosRenderer4.GizmoRendererType type"
  },
  "api/Engine4.Rendering.IVisualizer.html": {
    "href": "api/Engine4.Rendering.IVisualizer.html",
    "title": "Interface IVisualizer | Engine4 Manual",
    "keywords": "Interface IVisualizer Inteface to the visualizer public interface IVisualizer Properties WorkingSimplexCase Is this visualizer supports given simplex case? SimplexMode WorkingSimplexCase { get; } Methods Clear(Mesh) Tell to clear the buffer void Clear(Mesh m) End(Mesh, VertexProfiles) Marks the end of the visualizing function void End(Mesh m, VertexProfiles profile) Initialize(Buffer3) Marks the beginning of the visualizing function void Initialize(Buffer3 helper) Render(Vector4[], Int32) Per-simplex visualize method Assume Vector4[] is Vector3[] with w = 0 each void Render(Vector4[] buffer, int count) Render(VertexProfile[], Int32) Per-simplex profile visualize method void Render(VertexProfile[] buffer, int count)"
  },
  "api/Engine4.Rendering.Modeler4.html": {
    "href": "api/Engine4.Rendering.Modeler4.html",
    "title": "Class Modeler4 | Engine4 Manual",
    "keywords": "Class Modeler4 Base class from custom 4D model creation. public abstract class Modeler4 : MonoBehaviour4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Modeler4 Cylinder4 Primitive4 Sphere4 Constructors Modeler4() protected Modeler4() Methods CreateModel(Buffer4) The starting method for generating model public abstract void CreateModel(Buffer4 buffer)"
  },
  "api/Engine4.Rendering.Modifier4.html": {
    "href": "api/Engine4.Rendering.Modifier4.html",
    "title": "Class Modifier4 | Engine4 Manual",
    "keywords": "Class Modifier4 Base class from custom 4D model modifier. public abstract class Modifier4 : MonoBehaviour4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Modifier4 Constructors Modifier4() protected Modifier4() Methods ModifyModel(Buffer4) public abstract void ModifyModel(Buffer4 buffer)"
  },
  "api/Engine4.Rendering.SolidVisualizer4.html": {
    "href": "api/Engine4.Rendering.SolidVisualizer4.html",
    "title": "Class SolidVisualizer4 | Engine4 Manual",
    "keywords": "Class SolidVisualizer4 Default Engine4 triangle visualizer public class SolidVisualizer4 : IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object SolidVisualizer4 Constructors SolidVisualizer4() public SolidVisualizer4() Fields refineNormals Should the visualizer recalculate the normal? (default is true) public bool refineNormals smoothNormals Should the visualizer merges any duplicate vertex? (default is false) public bool smoothNormals Properties WorkingSimplexCase Always return Triangle public SimplexMode WorkingSimplexCase { get; } Implements IVisualizer"
  },
  "api/Engine4.Rendering.Sphere4.html": {
    "href": "api/Engine4.Rendering.Sphere4.html",
    "title": "Class Sphere4 | Engine4 Manual",
    "keywords": "Class Sphere4 Built-in modeler to create a sphere in 4D. public class Sphere4 : Modeler4 Namespace Engine4.Rendering Inheritance System.Object MonoBehaviour4 Modeler4 Sphere4 Remarks This sphere has a configurable subdivision and radius and extent, So it can be extended to a cube, sphere, cylinder, or rounded cube. Constructors Sphere4() public Sphere4() Fields extent Extent of the cube public Vector4 extent radius Radius of the sphere public float radius subdivision Subdivision level public int subdivision Remarks Internally the subdivision level is multiplied by 2 so it's always even. Be advised that setting too much subdivision level could broken the output mesh."
  },
  "api/Engine4.Rendering.UvMapMethod.html": {
    "href": "api/Engine4.Rendering.UvMapMethod.html",
    "title": "Enum UvMapMethod | Engine4 Manual",
    "keywords": "Enum UvMapMethod UV map unwrapping methods public enum UvMapMethod Fields Name Description Cylindrical Cylindrical unwrapping Directional Flatten Indices based on given normal None Rotate only. Nothing special. NormalBased Flatten Indices based on its normal Spherical Spherical unwrapping"
  },
  "api/Engine4.Rendering.Visualizer4.html": {
    "href": "api/Engine4.Rendering.Visualizer4.html",
    "title": "Class Visualizer4 | Engine4 Manual",
    "keywords": "Class Visualizer4 Base class for custom visualizer public abstract class Visualizer4 : MonoBehaviour4, IVisualizer Namespace Engine4.Rendering Implements IVisualizer Inheritance System.Object MonoBehaviour4 Visualizer4 ParticleExtended4 SolidExtended4 Constructors Visualizer4() protected Visualizer4() Properties WorkingSimplexCase Is this visualizer supports given simplex case? public abstract SimplexMode WorkingSimplexCase { get; } Methods Clear(Mesh) Tell to clear the buffer public abstract void Clear(Mesh m) End(Mesh, VertexProfiles) Marks the end of the visualizing function public abstract void End(Mesh m, VertexProfiles profile) Initialize(Buffer3) Marks the beginning of the visualizing function public abstract void Initialize(Buffer3 helper) Render(Vector4[], Int32) Per-simplex visualize method Assume Vector4[] is Vector3[] with w = 0 each public abstract void Render(Vector4[] buffer, int count) Render(VertexProfile[], Int32) Per-simplex visualize method Assume Vector4[] is Vector3[] with w = 0 each public abstract void Render(VertexProfile[] buffer, int count) Implements IVisualizer"
  },
  "api/Engine4.SphereBounds4.html": {
    "href": "api/Engine4.SphereBounds4.html",
    "title": "Struct SphereBounds4 | Engine4 Manual",
    "keywords": "Struct SphereBounds4 Bounding with shape sphere public struct SphereBounds4 Constructors SphereBounds4(Bounds4) Create a sphere from box bounding public SphereBounds4(Bounds4 bound) SphereBounds4(Vector4, Single) Create sphere bounding public SphereBounds4(Vector4 center, float radius) Fields center Center position of the sphere public Vector4 center radius Radius of the sphere public float radius Methods Contains(Vector4) Is this sphere contains the point? public bool Contains(Vector4 point) IsIntersecting(Plane4, SphereBounds4) Is the sphere overlap the plane? public static bool IsIntersecting(Plane4 plane, SphereBounds4 sphere) IsIntersecting(SphereBounds4, SphereBounds4) Is both sphere colliding? public static bool IsIntersecting(SphereBounds4 a, SphereBounds4 b)"
  },
  "api/Engine4.Tensor4.html": {
    "href": "api/Engine4.Tensor4.html",
    "title": "Struct Tensor4 | Engine4 Manual",
    "keywords": "Struct Tensor4 6x6 matrix to represet Tensor inertia of an object in 4D. public struct Tensor4 Remarks Because its immense computation size, this matrix is intended only for holding inertia data for the internal physics engine. The elements is stored in row-major order. Constructors Tensor4(Euler4) Create a diagonal tensor matrix. public Tensor4(Euler4 scale) Tensor4(Euler4, Euler4, Euler4, Euler4, Euler4, Euler4) Create and assign matrix values with rows. public Tensor4(Euler4 x, Euler4 y, Euler4 z, Euler4 t, Euler4 u, Euler4 v) Tensor4(Single) Create a diagonally uniform tensor matrix. public Tensor4(float scale) Fields et Fourth row of the matrix public Euler4 et eu Fifth row of the matrix public Euler4 eu ev Sixth row of the matrix public Euler4 ev ex First row of the matrix public Euler4 ex ey Second row of the matrix public Euler4 ey ez Third row of the matrix public Euler4 ez Properties Column0 Access first column of the matrix public Euler4 Column0 { get; set; } Column1 Access first column of the matrix public Euler4 Column1 { get; set; } Column2 Access first column of the matrix public Euler4 Column2 { get; set; } Column3 Access first column of the matrix public Euler4 Column3 { get; set; } Column4 Access first column of the matrix public Euler4 Column4 { get; set; } Column5 Access first column of the matrix public Euler4 Column5 { get; set; } identity Create a tensor as an identity matrix. public static Tensor4 identity { get; } Item[Int32] Get Nth-row of the matrix public Euler4 this[int index] { get; set; } zero Create a tensor with zero values. public static Tensor4 zero { get; } Methods Column(Int32) Get Nth-column of the matrix public Euler4 Column(int i) Cross(Matrix4) Create inertia from rotation matrix. public static Tensor4 Cross(Matrix4 t) Inverse(Tensor4) Inverse the tensor. public static Tensor4 Inverse(Tensor4 m) Remarks The operation is working, but unoptimized, yet expensive. OuterProduct(Vector4, Vector4) ? (WIP) public static Tensor4 OuterProduct(Vector4 u, Vector4 v) Transform(Tensor4, Matrix4) Rotate the tensor orientation by the matrix public static Tensor4 Transform(Tensor4 I, Matrix4 r) Transform(Tensor4, Matrix4x5, Single) Transform the inertia. public static Tensor4 Transform(Tensor4 I, Matrix4x5 T, float mass) Transform(Vector4, Single) Create a tensor translation. public static Tensor4 Transform(Vector4 p, float mass) Transpose(Tensor4) Transpose the tensor. public static Tensor4 Transpose(Tensor4 m) Operators Addition(Tensor4, Tensor4) Scale the tensor. public static Tensor4 operator +(Tensor4 lhs, Tensor4 rhs) Multiply(Tensor4, Euler4) Transform euler rotation by the tensor. public static Euler4 operator *(Tensor4 lhs, Euler4 rhs) Multiply(Tensor4, Tensor4) Combine two tensor. public static Tensor4 operator *(Tensor4 lhs, Tensor4 rhs) Multiply(Tensor4, Single) Scale the tensor. public static Tensor4 operator *(Tensor4 lhs, float f) Subtraction(Tensor4, Tensor4) Element-wisely subract two tensor. public static Tensor4 operator -(Tensor4 lhs, Tensor4 rhs)"
  },
  "api/Engine4.Transform4.html": {
    "href": "api/Engine4.Transform4.html",
    "title": "Class Transform4 | Engine4 Manual",
    "keywords": "Class Transform4 Transformation component in 4D public class Transform4 : MonoBehaviour Namespace Engine4 Inheritance System.Object Transform4 Constructors Transform4() public Transform4() Properties eulerAngles Rotation (in euler) to world space public Euler4 eulerAngles { get; set; } forward Get the forward (Z+) world axis of the transform public Vector4 forward { get; } localEulerAngles Rotation (in euler) relative to parent public Euler4 localEulerAngles { get; set; } localPosition Position relative to parent public Vector4 localPosition { get; set; } localRotation Rotation (in matrix) relative to parent public Matrix4 localRotation { get; set; } localScale Scaling value. public Vector4 localScale { get; set; } Remarks Scaling won't affect to its children. localToWorldMatrix The analogous localToWorldMatrix just for 4 manipulations public Matrix4x5 localToWorldMatrix { get; } Remarks Scale doesn't included in the matrix overward Get the overward (W+) world axis of the transform public Vector4 overward { get; } parent Get Transform4 in ancestor. Note that not every objects have Transform4. public Transform4 parent { get; } position Position relative to world space public Vector4 position { get; set; } rightward Get the right (X+) world axis of the transform public Vector4 rightward { get; } rotation Rotation relative to world space public Matrix4 rotation { get; set; } update Event to be fired when this transform changed. public TransformCallback update { get; set; } upward Get the up (Y+) world axis of the transform public Vector4 upward { get; } worldToLocalMatrix The analogous worldToLocalMatrix just for 4 manipulations public Matrix4x5 worldToLocalMatrix { get; } Remarks Scale doesn't included in the matrix Methods Rotate(Euler4, Space4) Rotate this transform (in euler) in given space orientation. public void Rotate(Euler4 value, Space4 space) Rotate(Matrix4, Space4) Rotate this transform (in matrix) in given space orientation. public void Rotate(Matrix4 value, Space4 space) Rotate(Quaternion, Space4) Rotate this transform (in 3D quaternion) in given space orientation. public void Rotate(Quaternion value, Space4 space) Translate(Vector4, Space4) Translate this transform in given space orientation. public void Translate(Vector4 value, Space4 space)"
  },
  "api/Engine4.TransformCallback.html": {
    "href": "api/Engine4.TransformCallback.html",
    "title": "Delegate TransformCallback | Engine4 Manual",
    "keywords": "Delegate TransformCallback Delegate to notice transform changes public delegate void TransformCallback();"
  },
  "api/Engine4.Vector4.html": {
    "href": "api/Engine4.Vector4.html",
    "title": "Struct Vector4 | Engine4 Manual",
    "keywords": "Struct Vector4 Vector in 4D. public struct Vector4 : IEquatable<Vector4> Remarks Not to be confused with UnityEngine's Vector4. For all operation in Engine4, Vector4 refers to this struct. We create the duplicate because UnityEngine's variant is lack of static utilities. Constructors Vector4(Int32, Single) Create an euler data with a value for given axis index. public Vector4(int axis, float value) Remarks See Item[Int32] for axis index. Other axis will set as zero by default Vector4(Single) Create a uniform vector. public Vector4(float scale) Vector4(Single, Single, Single, Single) Create a new vector data with given individual values. public Vector4(float x, float y, float z, float w) Fields w W axis of the vector public float w x X axis of the vector public float x y Y axis of the vector public float y z Z axis of the vector public float z Properties forward The vector pointing to front direction public static Vector4 forward { get; } Item[Int32] Get or set a vector value in given axis index public float this[int i] { get; set; } Remarks Axis index in order: X, Y, Z, W. one Vector with values of one public static Vector4 one { get; } overward The vector pointing to over direction public static Vector4 overward { get; } rightward The vector pointing to right direction public static Vector4 rightward { get; } upward The vector pointing to up direction public static Vector4 upward { get; } zero Vector with zero values public static Vector4 zero { get; } Methods Abs(Vector4) Get the absolute version of the vector public static Vector4 Abs(Vector4 v) Clamp(Vector4, Vector4, Vector4) Clamp vector T between A and B. public static Vector4 Clamp(Vector4 a, Vector4 b, Vector4 t) ComputeBasis(Vector4[]) public static void ComputeBasis(Vector4[] vector) Cross(Vector4, Vector4, Vector4) Get the cross operation between three vector public static Vector4 Cross(Vector4 a, Vector4 b, Vector4 c) Remarks This cross operation finds the other vector that perpendicular to the three vector. The convention used such that A and B is equivalent to the left hand rule if C is positive overward. Distance(Vector4, Vector4) Get the distance between two vector public static float Distance(Vector4 a, Vector4 b) DistanceSq(Vector4, Vector4) Get the squared distance between two vector public static float DistanceSq(Vector4 a, Vector4 b) Dot(Vector4, Vector4) Get the dot operation between two vector public static float Dot(Vector4 a, Vector4 b) Invert(Vector4) Axis-wisely inverse the vector public static Vector4 Invert(Vector4 v) See Also Invert(Single) Length(Vector4) Get the length (magnitude) of the vector public static float Length(Vector4 v) LengthSq(Vector4) Get the squared length of the vector public static float LengthSq(Vector4 v) Remarks This method is much faster, and should be used if it means only for comparison Lerp(Vector4, Vector4, Single) Interpolate two vector by T and clamp. public static Vector4 Lerp(Vector4 a, Vector4 b, float t) Remarks The interpolation is clamped between zero to one LerpUnclamped(Vector4, Vector4, Single) Interpolate two vector by T public static Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t) Remarks The interpolation is not clamped. Max(Vector4, Vector4) Axis-wisely choose the largest range of two vector. public static Vector4 Max(Vector4 a, Vector4 b) MaxPerElem(Vector4) Return the largest axis value in the vector. public static float MaxPerElem(Vector4 a) MaxPerElemIdx(Vector4) Return the axis index that has largest value in the vector. public static int MaxPerElemIdx(Vector4 a) Min(Vector4, Vector4) Axis-wisely choose the smallest range of two vector. public static Vector4 Min(Vector4 a, Vector4 b) MinPerElem(Vector4) Return the smallest axis value in the vector. public static float MinPerElem(Vector4 a) MinPerElemIdx(Vector4) Return the axis index that has smallest value in the vector. public static int MinPerElemIdx(Vector4 a) Normalize(Vector4) Normalize the vector. public static Vector4 Normalize(Vector4 v) Sign(Vector4) Get the sign version of the vector public static Vector4 Sign(Vector4 n) Operators Addition(Vector4, Vector4) Axis-wisely add two vector values public static Vector4 operator +(Vector4 lhs, Vector4 rhs) Division(Vector4, Single) Axis-wisely divide an euler values with a number public static Vector4 operator /(Vector4 lhs, float f) Equality(Vector4, Vector4) Equivalence check public static bool operator ==(Vector4 lhs, Vector4 rhs) GreaterThan(Vector4, Vector4) Compare if A is greater than B in all axes public static bool operator>(Vector4 lhs, Vector4 rhs) Implicit(Vector4 to Vector3) Implicit conversion from UnityEngine's Vector3 public static implicit operator Vector3(Vector4 v) Implicit(Vector4 to Vector4) Implicit conversion to UnityEngine's Vector4 public static implicit operator Vector4(Vector4 v) Implicit(Vector4 to Vector4) Implicit conversion from UnityEngine's Vector4 public static implicit operator Vector4(Vector4 v) Inequality(Vector4, Vector4) Inequivalence check public static bool operator !=(Vector4 lhs, Vector4 rhs) LessThan(Vector4, Vector4) Compare if A is smaller than B in all axes public static bool operator <(Vector4 lhs, Vector4 rhs) Multiply(Vector4, Vector4) Axis-wisely multiply two vector. public static Vector4 operator *(Vector4 a, Vector4 b) Multiply(Vector4, Single) Axis-wisely scale an euler values with a number public static Vector4 operator *(Vector4 lhs, float f) Multiply(Single, Vector4) Axis-wisely scale an euler values with a number public static Vector4 operator *(float f, Vector4 lhs) Subtraction(Vector4, Vector4) Axis-wisely subtract two euler values public static Vector4 operator -(Vector4 lhs, Vector4 rhs) UnaryNegation(Vector4) Negate each vector axis public static Vector4 operator -(Vector4 lhs) Implements System.IEquatable<T>"
  },
  "api/Engine4.VertexProfile.html": {
    "href": "api/Engine4.VertexProfile.html",
    "title": "Struct VertexProfile | Engine4 Manual",
    "keywords": "Struct VertexProfile Additional vertex channel public struct VertexProfile Constructors VertexProfile(Color, Vector4, Vector4, Vector4) Create new vertex profile public VertexProfile(Color color, Vector4 uv, Vector4 uv2, Vector4 uv3) Fields color Color of the vertex public Color color uv First UV channel public Vector4 uv uv2 Second UV channel public Vector4 uv2 uv3 Third UV channel public Vector4 uv3 Properties initial Default state for VertexProfile public static VertexProfile initial { get; } Methods Lerp(VertexProfile, VertexProfile, Single) Interpolate between two profile public static VertexProfile Lerp(VertexProfile a, VertexProfile b, float t) LerpUnclamped(VertexProfile, VertexProfile, Single) Interpolate between two profile (without clamping) public static VertexProfile LerpUnclamped(VertexProfile a, VertexProfile b, float t) Transform(Matrix4x4, VertexProfile) Transform UV Profile public static VertexProfile Transform(Matrix4x4 t, VertexProfile profile) Transform(Matrix4x4, VertexProfile, Vector4) Transform UV Profile public static VertexProfile Transform(Matrix4x4 t, VertexProfile profile, Vector4 center)"
  },
  "api/Engine4.VertexProfiles.html": {
    "href": "api/Engine4.VertexProfiles.html",
    "title": "Enum VertexProfiles | Engine4 Manual",
    "keywords": "Enum VertexProfiles Additional channels to be included when generating the mesh output [Flags] public enum VertexProfiles Fields Name Description Color Generate color ColorAndUV Generate color and first UV ColorAndUV2 Generate color and first, second UV ColorAndUV3 Generate color and first, secord, third UV None Only generate vertices and indices UV Generate first UV UV2 Generate first, second UV UV3 Generate first, second, and third UV Extension Methods VertexProfilesUtility.HasUV() VertexProfilesUtility.HasUV2() VertexProfilesUtility.HasUV3() VertexProfilesUtility.HasColor()"
  },
  "api/Engine4.VertexProfilesUtility.html": {
    "href": "api/Engine4.VertexProfilesUtility.html",
    "title": "Class VertexProfilesUtility | Engine4 Manual",
    "keywords": "Class VertexProfilesUtility Vertex profile extensions public static class VertexProfilesUtility Namespace Engine4 Inheritance System.Object VertexProfilesUtility Methods HasColor(VertexProfiles) Is Color calculated? public static bool HasColor(this VertexProfiles v) HasUV(VertexProfiles) Is UV calculated? public static bool HasUV(this VertexProfiles v) HasUV2(VertexProfiles) Is UV2 calculated? public static bool HasUV2(this VertexProfiles v) HasUV3(VertexProfiles) Is UV3 calculated? public static bool HasUV3(this VertexProfiles v)"
  },
  "api/Engine4.Viewer4.html": {
    "href": "api/Engine4.Viewer4.html",
    "title": "Class Viewer4 | Engine4 Manual",
    "keywords": "Class Viewer4 The camera of four-dimensional scene public class Viewer4 : MonoBehaviour4 Namespace Engine4 Inheritance System.Object MonoBehaviour4 Viewer4 Remarks A game engine needs a camera to display the scene output. Viewer is the camera. However, the output belongs to individual renderer, Hence only one viewer is allowed in scene. Constructors Viewer4() public Viewer4() Fields background Should renderers do the computation in separate thread? (recommended) public bool background Remarks Changes to this variable requires a call to Engine4.Viewer4.Validate to take effect. projection Projection mode used by the viewer public ProjectionMode projection Remarks Changes to this variable requires a call to Engine4.Viewer4.Validate to take effect. update Event to be called when something updated in viewer By default it is filled by Viewer4 public static ViewerDispatch update Properties main Main access to the Viewer4 public static Viewer4 main { get; } projector Get access to internal projector public Projector4 projector { get; } projectorJob Get access to internal multithreaded projector public ProjectorJob projectorJob { get; } viewerToWorldMatrix Camera to world matrix transformation public Matrix4x5 viewerToWorldMatrix { get; } worldToViewerMatrix World to camera matrix transformation public Matrix4x5 worldToViewerMatrix { get; } Methods SetDirty(DirtyLevel) Force a global invalidation public void SetDirty(DirtyLevel level)"
  },
  "api/Engine4.ViewerDispatch.html": {
    "href": "api/Engine4.ViewerDispatch.html",
    "title": "Delegate ViewerDispatch | Engine4 Manual",
    "keywords": "Delegate ViewerDispatch Delegate to notice viewer update public delegate void ViewerDispatch(DirtyLevel level);"
  },
  "api/Engine4.VisualizeMode.html": {
    "href": "api/Engine4.VisualizeMode.html",
    "title": "Enum VisualizeMode | Engine4 Manual",
    "keywords": "Enum VisualizeMode What kind of visualization need to be shown? public enum VisualizeMode Fields Name Description Custom Use custom visualizer attached in the game object Particle Visualize using mesh points Solid Visualize using mesh triangles Wire Visualize using mesh wires (wireframe)"
  },
  "api/Engine4.html": {
    "href": "api/Engine4.html",
    "title": "Namespace Engine4 | Engine4 Manual",
    "keywords": "Namespace Engine4 Classes Buffer3 Temporary representation of a 3D mesh Buffer4 Temporary representation of 4D mesh MonoBehaviour4 Base class to get access with main Engine4 components PhysicsMaterial4 Additional configuration asset for 4D physics simulation Renderer4 Component to render and manage outputs from modelers Transform4 Transformation component in 4D VertexProfilesUtility Vertex profile extensions Viewer4 The camera of four-dimensional scene Structs Bounds4 Representation for bounds in 4 Euler4 Rotation unit on each plane in 4D Matrix4 A 4x4 matrix to describe 4D rotations Matrix4x5 A 4x5 matrix to describe 4D transformation Plane4 Mathematical abstraction of a plane that split spaces in 4D Ray4 Represent of a line that extends to infinity SphereBounds4 Bounding with shape sphere Tensor4 6x6 matrix to represet Tensor inertia of an object in 4D. Vector4 Vector in 4D. VertexProfile Additional vertex channel Enums Axis4 Axis in enumeration BodyType Type of a rigidbody CollisionState Collision state of an impact DirtyLevel Kind of validation requested ProjectionMode Projection modes SimplexMode Simplex contain points. Simplex count must be divisible by 1 Space4 Space relatives for transformations VertexProfiles Additional channels to be included when generating the mesh output VisualizeMode What kind of visualization need to be shown? Delegates TransformCallback Delegate to notice transform changes ViewerDispatch Delegate to notice viewer update"
  }
}